### `Composition API`

- 它可以把 `一个逻辑的代码都收集在一起` 单独写个`hook`,然后再引入，这样就不需要到处分布，也不会显得很乱

### `Fragment`

>  在 `template` 中不再需要一个根元素包裹

```vue
<template>
 <img alt="Vue logo" src="./assets/logo.png" />
 <HelloWorld msg="Welcome to Your Vue.js + TypeScript App" />
</template>
```

- 实际上内部会将多个标签包含在一个`Fragment`虚拟元素中

- 好处: 减少标签层级, 减小内存占用

### `script` 差异

```vue
<script lang="ts">
import { defineComponent} from 'vue'

export default defineComponent({
  name: 'App',
  setup() {
    return {
        // 这里的属性 和 方法 会合并到 data 函数 和 methods 对象里
    }
  },
})
</script>
```

- 可以在`script` 使用 `ts` 只需 设置 `lang` 即可
- `defineComponent` 方法创建一个组件
- `export default` 直接导出一个组件

### `setup`

> `setup` 是 `Composition API`的入口

#### `setup` 执行顺序

它在`beforeCreate`**之前执行一次**，`beforeCreate`这个钩子 的任务就是初始化，在它之前执行，那么 `this` 就没有被初始化 `this = undefined` 这样就不能通过 `this` 来调用方法 和 获取属性

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151621443.webp)

#### `setup` 返回值

`setup` 返回的是一个**对象**，这个对象的属性会与组件中 `data` 函数返回的对象进行**合并**，返回的方法和 `methods` 合并，合并之后直接可以在模板中使用，如果有重名的情况，会使用 `setup` 返回的**属性**和**方法**，`methods` 和 `data` 能够拿到 `setup` 中的方法则进行了合并，反之 `setup` 不能拿到它们的属性和方法，因为这个时候 `this` = `undefined`![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151639845.webp)

#### `Suspense` 组件

> `setup` 使用 `async`/`await`

需要 `setup` 返回数据那么它肯定就不能使用 `async` 修饰，这样返回 `promise` 是不想看见的情况，如果硬要用 `async` 修饰，就得在它的父组件外层嵌套一个`suspense`(不确定)内置组件，里面放置一些不确定的操作，比如可以把异步组件放入进去

##### 1.子组件

```vue
<template> 
  {{ res }}
</template>

<script lang="ts">
import { defineComponent } from 'vue'
export default defineComponent({ 
  name: 'Son', 
  async setup() {   
    const res = await axios.get('地址')   
    return {    
      res, 
    } 
  },
})
</script>
```

##### 2.父组件

```vue
<template>  
    <Suspense>     
        <!-- 子组件-->  
      <Son></Son> 
  </Suspense>
</template>
```

#### `setup` 参数

> `setup`(`props`, `context`)

- `setup` 函数中的第一个参数是 `props`。它接收父组件传递的值，就是父子组件信息传递的 `props`

第二个参数是 `context` ,里面包含3个属性 `{ attrs, slots, emit }`，这三个属性分别对应 `this.$attrs`，`this.$slots`，`this.$emit`

- `attrs`: 除了 `props` 中的其他属性
- `slots`: 父组件传入插槽内容的对象
- `emit`: 用于父子组件通信

### `ref`

> 定义/转为 响应式

在上面 `setup` 写的数据都**不是响应式的**，修改了数据，视图并不会更新

在 `Vue3` 中提供了两种方式定义响应式数据，先来介绍下 `ref`

导入 `ref` 方法

```ts
import { defineComponent, ref } from 'vue'
```

- 可以先声明一个 **基本类型** 变量后再当做 `ref` 的形参传进去

- 或者直接在 `ref` 中传入

  ```ts
    setup() {   
      // 方式一  
      let number1 = ref(10) 
      let num = 0   
      // 方式二  
      let number2 = ref(num)  
      return {} 
    },
  ```

- 来查看一下 `number1` 是什么吧

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151931707.webp)

-  可以看见的是 `number1` 是一个 `Ref` 对象，设置的 `10` 这个值在这个对象的 `value` 属性上
  - 修改的时候必须要修改的是 `number1.value`
  - 通过给`value`属性添加 `getter`/`setter` 来实现对数据的劫持
- 在模板上使用的时候 不用写 `number1.value` 直接写 `number1` 即可
- 在模板编译的时候会自动加上 `value`

```vue
<template> 
  {{ number1 }} 
  <button @click="updateNum">+</button>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue'
export default defineComponent({ 
  name: 'Son', 
  setup() {  
    let number1 = ref(10)  
  
    // 修改 number1  
    function updateNum() {   
      number1.value++   
    }  
    return {  
      number1,   
      updateNum,  
    } 
  },
})
</script>
```

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151934592.webp)

使用起来完全没有问题

刚才强调了说 `ref` 接收 基本类型的数据，那么它可以接收 复杂类型吗，`object` 类型等，当然可以

给 `ref` 传入复杂类型，其实它是调用 `reactive` 来实现的

### `ref` 获取元素

同样的 `ref` 还可以用了获取元素

在 `Vue2.X` 中是怎么获取的呢，先在 标签上定义 `:ref='XXX'` 然后 `this.$refs.XXX` 来获取

在 `Vue3` 上获取元素就有些许不同了

> 1.首先在 模板元素上 `ref='XXX'` 这里不用 `v-bind`

```vue
<template> 
  <div id="haha" ref="haha"></div>
</template>
```

> 2.在 `setup` 中

得给 `ref` 指定类型 `HTMLElement`

```vue
setup() { 
  let haha = ref<HTMLElement|null>(null) 
  console.log(haha)  
  
  return {  
    haha, 
  }
},
```

如果在组件中需要使用到 `haha` ，就必须把 `haha` `return` 出去合并 `data`

来看看打印的是什么

![](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151937422.webp)

可以看见 `haha` 是 `Ref` 对象，`value` 就是想要获取的元素

然后可以对 `haha` 这个 `DOM` 元素进行操作，比如这个

```ts
haha.style.fontSize = '20px'
```

### `reactive`

`reactive` 接收一个普通对象然后返回该普通对象的响应式`代理对象`

它的底层就是使用 `Proxy` 进行代理

> 简单写个Vue3响应式例子来说下 `Proxy`

new Proxy(target, handler)

- `target` ：要使用 `Proxy` 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
- `handler`：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `p`

```ts
// 模拟 Vue data
let data = {  
    msg: '',   
    age: '',
}
// 模拟 Vue 的一个实例
// Proxy 第一个
let vm = new Proxy(data, {   
    // get() 获取值  
    // target 表示需要代理的对象这里指的就是 data  
    // key 就是对象的 键  
    get(target, key) {  
        return target[key]  
    },  
    // 设置值  
    // newValue 是设置的值   
    set(target, key, newValue) {     
        // 也先判断下是否和之前的值一样 节省性能    
        if (target[key] === newValue) return    
        // 进行设置值    
        target[key] = newValue   
        document.querySelector('#app').textContent = target[key]    
    },
})
```

> `reactive` 基础用法

导入

```ts
import { defineComponent, reactive } from 'vue'
```

简单使用

```ts
setup() {  
    let obj = reactive({    
        name: '小浪',    
        age: 21,  
    })  
    return {     
        obj,  
    }
}
```

来看看返回的 `Proxy` 对象

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151942178.webp)

数据都在 `target` 中，

在模板使用直接 `{{obj.name}}` 即可

修改直接修改 `obj[name]` `=` `‘xxx’`

操作代理对象,obj中的数据也会随之变化，同时如果想要在操作数据的时候,界面也要跟着重新更新渲染,也是操作代理对象

> 响应式的数据是深层次的（递归深度响应式）

对于多层嵌套的数据也是响应式的

```ts
setup() {  
    let obj = reactive({   
        name: '小浪',     
        age: 21,     
        phone: {       
            p_name: '小米',    
            p_apps: {        
                app_name: '小米运动',       
            },      
        },  
     })  
     function upadateName() {    
         obj.phone.p_apps.app_name = '掘金'   
     }  
     console.log(obj)  
     
     return {     
         obj,     
         upadateName, 
    }
},
```

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151944345.webp)

> shallowReactive

一个简单的 reactive ，只把第一层的对象改为响应式

> 使用 `ref` 传入对象

```ts
setup() {  
    let obj = ref({    
        name: '小浪',   
        age: 21,  
    }) 
    console.log(obj)   
    
    return {     
        obj,   
    }
}
```

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151945188.webp)

实际上是 `ref` 是使用 `reactive` 来进行操作的

### `toRefs`

这个方法可以把 `reactive` 响应式对象，转化为 普通对象，普通对象的每个属性都是 `Ref` 对象，这样的话保证了 `reactive` 的每个属性还是响应式的，我们还可以把每个属性进行分解使用，这样在组件就不用 **obj[属性]**，代码量减轻了

```ts
setup() { 
  const user = reactive({   
    name: '小浪',  
    age: 21, 
  }) 
  
  let userObj = toRefs(user) 
  console.log(userObj) 
  
  return {}
}
```

![图片](https://cdn.jsdelivr.net/gh/itxcr/oss/images/202202151947434.webp)

可以看见 `name` 和 `age` 已经变成了 `Ref` 对象

可以解构 出 `name` 和 `age` 单独使用

```ts
setup() { 
  const user = reactive({  
    name: '小浪',  
    age: 21, 
  }) 
  
  let userObj = toRefs(user) 
  
  return { 
    ...userObj, 
  }
}
```

### `toRef`

它的作用和 `toRefs` 差不多，但是它只能把响应式对象/普通对象的**某一个**属性变为 `Ref` 对象

> 可以用来为源响应式对象上的 `property` 属性创建一个 `ref`。然后可以将 `ref` 传递出去，从而保持对其源 `property` 的响应式连接

```ts
export default { 
  setup(props) {  
    useSomeFeature(toRef(props, 'foo'))  
  }
}

function useSomeFeature(foo: Ref) { 
  // ...
}
```

拷贝了一份新的数据值单独操作, 更新时相互不影响

当需要将 `prop` 的 `ref` 传递给复合函数时，`toRef` 很有用

从官方文档看出，用于在组件之前的传递数据 从 `props` 拿出 `'foo'` 属性给复合函数，复合函数 `useSomeFeature`，接收的参数 `foo` 为 `Ref` 类型，刚好可以使用`toRef` 来进行转化