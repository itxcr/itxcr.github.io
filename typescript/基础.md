### 类型别名

允许使用 type 关键字声明类型别名：

```ts
type PrimitiveArray = Array<string | number | boolean>
type MyNumber = number
type NgScope = ng.IScope
type Callback = () => void
```

### 环境声明

允许在 TypeScript 中创建一个不会被编译到 Javascript 中的变量。这个特性是用来促进与现有 Javascript 代码、DOM（文档对象模型）、BOM（浏览器对象模型）结合而设计的。

有时，我们希望调用一个未被定义的对象上的方法，比如 window 对象上的 console 方法。

当访问 DOM 或 BOM 对象时，我们没有遇到错误，是因为这些对象已经在一个特殊的 Typescript 文件（被称为 声明文件）中被声明了。可以使用 declare 操作符创建一个环境声明。

下面代码中，声明一个被 customConsole 对象实现的接口。然后使用 declare 操作符在作用域中增加一个 customConsole 对象：

```ts
interface ICustomConsole {
    log(arg: string): void
}
declare var cuntomConsole: ICustomConsole
```

然后就可以在没有编译错误的情况下使用 cuntomConsole

`cuntomConsole.log("测试")`

Typescript 默认包含一个名为 lib.d.ts 的文件，它提供了像 DOM 这种 Javascript 内置库的接口声明。

使用 .d.ts 结尾的声明文件，是用来提高 Typescript 对第三方库和像 Node.js 或浏览器这种运行时环境的兼容性的。

### 算数运算符

`+、-、*、/、%、++、——`

### 接口

在 TS 中，可以使用接口来确保类拥有指定的结构

```ts
interface loggerInterface {
  log(arg: any): void
}

class Logger implements loggerInterface {
  log(arg) {
    if (typeof console.log === 'function') {
      console.log(arg)
    }else {
      alert(arg)
    }
  }
}
```

上面定义了一个名为 loggerInterface 的接口，和一个实现了它的 Logger 类。TS 允许使用接口来约束对象。这让我们可以避免很多潜在的小错误：

```ts
interface UserInterface {
  name: string,
  password: string
}

let user: UserInterface = {
  name: '',
  pasword: '' //遗漏错误属性  '{ name: string; pasword: string; }' is not assignable to type 'UserInterface'
}
```

### 命名空间

又称内部模块，被用于组织一些具有某些内在联系的特性和对象。命名空间能够使代码结构更清晰，可以使用 namespace 和 export 关键字，在 TS 中声明命名空间。

```ts
namespace Geometry {
  interface VectorInterface {
  }

  export interface Vector2dInterface {
  }

  export interface Vector3dInterface {
  }

  export class Vector2d implements VectorInterface, Vector2dInterface {
  }

  export class Vector3d implements VectorInterface, Vector3dInterface {
  }
}
const vector2dInstance: Geometry.Vector2dInterface = new Geometry.Vector2d()
const vector3dInstance: Geometry.Vector3dInterface = new Geometry.Vector3d()
```

上面声明了一个包含 Vector2d、Vector3d类和VectorInterface、

Vector2dInterface、Vector3dInterface 接口的命名空间。注意，命名空间内的第一个接口声明前并没有 export 关键字。所以在命名空间外部，访问不到它。

### 综合运用

下面的例子用到了模块、类、函数和类型注解：

```ts
module Geometry {
  export interface Vector2dInterface {
    toArray(callback: (x: number[]) => void): void
    length(): number
    normalize()
  }

  export class Vector2d implements Vector2dInterface {
    private _x: number
    private _y: number

    constructor(x: number, y: number) {
      this._x = x
      this._y = y
    }

    toArray(callback: (x: number[]) => void): void {
      callback([this._x, this._y])

    }

    length(): number {
      return Math.sqrt(this._x * this._x + this._y * this._y)
    }

    normalize() {
      let len = 1 / this.length()
      this._x *= len
      this._y *= len
    }
  }
}
```

```ts
const vector: Geometry.Vector2dInterface = new Geometry.Vector2d(2, 3)
vector.normalize()
vector.toArray((vectorAsArray: number[]) => {
  console.log(vectorAsArray)
})
```

类型检查和智能提示会帮助创建 Vector2d 类的实例，单位化它的值，将其转化为数组。

### 自动化任务工具

自动化任务工具用来自动化地执行开发过程中需要重复进行的任务。这些任务包括编译 Ts 文件、压缩 Js 文件等等。

Gulp 使用的是流，Gulp 插件更倾向于使用代码来描述任务，这使得 Gulp 任务的可读性更高。

安装 Gulp

- `pnpm add gulp -D`

创建一个 `gulpfile.js` ，写完任务后执行 gulp 命令即可执行任务。

### 自动化测试工具

### 函数类型

通过使用可选的类型声明注解来显式声明一个元素的类型：

```ts
function greetNamed(name: string):string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

在上述函数中，定义了参数 name 的类型（string）和返回值类型（string）。有时候不只需要定义函数中元素的类型，还需要定义函数本身的类型。如下：

```ts
let greetUnnamed:(name: string) => string

greetUnnamed = function (name: string): string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

在上述例子中，声明了变量 greetUnnamed 及其类型。greetUnnamed 的类型是一个只包含一个名为 name 的 string 

类型参数、在调用后会返回类型为 string 的函数。在声明了这个变量之后，一个完全符合变量类型的函数被赋值给了它。

也可以声明 greetUnnamed 的类型，并在同一行中将一个函数赋值给它，而不是分割成两行，例如：

```ts
let greedUnnamed:(name: string) => string = function (name: string):string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

如上，之前的代码片段中同样声明了变量 greedUnnamed 和它的类型。我们也可以在同一行中把一个函数赋值给这个变量，被赋值的函数类型必须与变量类型相同。

### 有可选参数的函数

与 JS 不同，调用函数时传参的数量或类型不符合函数中定义的参数要求时，TS 编译器会报错。

```ts
function add(foo: number, bar: number, foobar: number): number {
  return foo + bar + foobar
}
```

上述函数名为 add 并包含三个 number 类型的参数：foo、bar 和 foobar。如果调用这个函数时没有完整地传入三个参数，会得到一个编译错误，提示提供地参数与函数声明中地参数无法匹配。

在一些场景下，我们也许想调用这个函数且不提供所有的参数。TS 提供了一个函数可选参数的特性，可以帮助增加这个函数的灵活性。可以在 TS 中通过在函数参数后追加一个字符 " ? "，指定函数参数是可选的。更新一下前面的函数，将 foobar 参数从必选参数修改为可选参数。

```ts
function add(foo: number, bar: number, foobar?: number): number {
  let result = foo + bar
  if (foobar !== undefined) result += foobar
  return result
}
```

修改后，提供两个或三个参数调用这个函数时，TS 编译器不再抛出错误。

值得注意的是，可选参数必须位于必选参数列表的后面。

### 有默认参数的函数

当函数有可选参数时，我们必须检测参数是否被传递了。

在一些场景中，应为一个可选参数设置默认值。

```ts
function add(foo: number, bar: number, foobar?: number): number {
  return foo + bar + (foobar !== undefined ? foobar : 0)
}
```

这个函数并没有错误，但是可以通过提供 foobar 参数的默认值，来代替标记其为可选参数，以改善其可读性。

```ts
function add(foo: number, bar: number, foobar: number = 0): number {
  return foo + bar + foobar
}
```

只需要在声明函数时使用 " = " 操作符提供一个默认值，即可指定函数参数是可选的。TS 编译器会在 JS 输出结果中生成一个 if 结构，在 foobar 参数没有传递给函数时设置一个默认值。

```js
function add(foo, bar, foobar) {
  if (foobar === void 0) {
    foobar = 0
  }
  return foo + bar + foobar
}
```

void 0 是 TS 编译器检测一个变量是否为 undefined 的用法。几乎所有开发者都使用 undefined 变量，几乎所有编译器都使用 void 0。

和可选参数一样，默认参数必须位于所有必选参数列表的后面。

### 有剩余参数的函数

已经学习了如何调用 add 函数并传递两个或三个参数，但是如果希望允许其他开发者传递四个或者五个参数呢？不得不再添加两个额外的默认参数或者可选参数。那如果希望允许开发者传递任意数量的参数呢？解决方案是使用剩余参数。剩余参数语法允许把不限量的参数表示为一个数组：

```ts
function add(...foo:number[]):number {
  let result = 0
  for (let i = 0, j = foo.length; i < j; i++) {
    result += foo[i]
  }
  return result
}
```

看一下上述代码片段，用一个参数 foo 替换了 参数 foo、bar 和 foobar。参数 foo 前面有一个三个点的省略号。一个剩余参数必须包含一个数组类型，否则就会出现编译错误。现在可以以任意数量的参数调用 add 函数：

```ts
add()               // 0
add(2)              // 2
add(2, 2)           // 4
add(2, 2, 2)        // 6
add(2, 2, 2, 2)     // 8
add(2, 2, 2, 2, 2)  // 10
```

虽然没有具体的参数数量限制，理论上可以取数字类型的最大值。但实际上，这依赖于如何调用这个函数。

Javascript 函数有一个被称为 arguments 的内建对象，这个对象可以通过 arguments 局部变量取到。arguments 变量是一个非常像数组的对象，包含了调用函数时的所有参数。

- arguments 对象暴露出一些标准数组中的属性和方法，但不是全部

检查 Javascript 的输出会发现，Typescript 遍历 arguments 参数，以便将所有参数添加到 foo 变量中：

```ts
function add() {
  let foo = []
  for (let i = 0, j = arguments.length; i < j; i++) {
    foo[i - 0] = arguments[i]
  }
  let result = 0
  for (let i = 0, j = foo.length; i < j; i++) {
    result += foo[i]
  }
  return result
}
```

虽然难以想象这个额外的遍历是否会成为一个性能瓶颈，但是如果认为这可能会对应用程序带来性能问题，应考虑不使用剩余参数而是只使用一个数组作为函数参数。

```ts
function add(foo: number[]):number {
  let result = 0
  for (let i =0, j = foo.length; i < j; i++) {
    result += foo[i]
  }
  return result
}
```

上述代码只有一个包含了 number 类型的数组。调用 API 会和剩余参数有一些不同，但是可以去除对函数参数列表进行遍历的操作：

```ts
add() // 提供的参数不匹配函数的签名
add(2) // 提供的参数不匹配函数的签名
add(2， 2) // 提供的参数不匹配函数的签名
add(2， 2， 2) // 提供的参数不匹配函数的签名

add([])             // 返回0
add([2])			// 返回2
add([2, 2])			// 返回4
add([2, 2, 2])      // 返回6
```

### 函数重载

函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。

在 TypeScript 中，可以通过声明一个函数的所有函数签名，然后再将一个签名作为实现。

```ts
function test(name: string):string    // 重载签名
function test(age: number): string    // 重载签名
function test(single: boolean):string // 重载签名
function test(value: string | number | boolean): string { // 实现签名
  switch (typeof value) {
    case 'string':
      return `My name is ${value}`
    case 'number':
      return `Im ${value} years old`
    case 'boolean':
      return value ? `I'm single` : `I'm not single`
    default:
      console.log('Invalid Operation!')
  }
}
```

### 特定重载签名

```ts
interface Document {
  createElement(tagName: 'div'):HTMLDivElement
  createElement(tagName: 'span'):HTMLSpanElement
  createElement(tagName: 'canvas'):HTMLCanvasElement
  createElement(tagName: string): HTMLElement
}
```

为函数 createElement 声明了三个特定重载签名和一个非特定重载签名。

当在一个对象中声明特定签名时，这个对象中必须被赋予至少一个非特定重载签名。从上面例子中可以发现，createElement 属性属于一个包含了三种特定重载签名的类型，并被赋予到非特定重载签名中。

当编写重载声明时，必须在最后列出非重载签名。

- 也可以通过使用联合类型来创建有同样名称和参数数量但是参数类型不一样的函数

### 函数作用域

一些低级语言（C）包含了底层内存管理特性。在拥有更高层抽象的编程语言（Typescript）中，当变量被创建时，内存就已经被分配，并且在它们不被使用时会被清理掉。这个清理内存的过程被称为垃圾回收，由 Javascript 运行时的垃圾回收器实现。

垃圾回收器通常很高效，但希望它能帮我们处理所有内存泄漏时就会有问题。垃圾回收器会在变量脱离作用域时清理掉它们，所以理解 Typescript 的作用域的工作机制对我们来说是非常重要的，这样就能理解变量的生命周期。

一些编程语言使用程序的源代码结构来指定哪些变量被引用（词法作用域），另一些编程语言使用程序的运行时堆栈状态来指定哪些变量被引用（动态作用域）。主要的现代编程语言使用词法作用域（包括 Typescript），词法作用域往往比动态作用域更容易被人和分析工具理解。

在绝大多数词法作用域编程语言中，变量的作用域为代码块（一段花括号包起来的代码）。在 TS 和 JS 中，变量的作用域在一个函数中：

```ts
function foo():void {
  if (true) {
    var bar: number = 0
  }
  alert(bar)
}
foo()
```

上面这个 foo 函数包含了一个 if 结构。在 if 结构中声明了一个名为 bar 的数字类型的变量，之后试图通过 alert 函数显示这个变量的值。

可能会认为这段代码会在第 5 行报错，因为 bar 变量应该在该函数调用时超出作用域。但是，当调用这个 foo 函数的时候，alert 函数会显示变量的值，并且不报任何错误，因为所有函数中的变量都在整个函数体的作用域内，即使是在另一个代码块中（除了函数代码块之外）。

在运行时中，所有的变量声明都会在函数执行前移动到函数的顶端，这种行为被称为变量提升。

- TS 先被编译为 JS 代码然后再执行，这意味着 TS 应用在运行时是一个 JS 应用。因为这个原因，当提及 TS 运行时的时候，就是在说 JS 运行时。

在上述代码被执行之前，运行时会将变量声明提升到函数的顶部。

```ts
function foo():void {
  var bar: number
  if (true) {
    bar = 0
  }
  alert(bar)
}
```

这意味着可以在变量声明前直接使用它：

```ts
function foo2():void {
  bar = 0
  var bar: number
  alert(bar)
}
foo2()
```

在上述代码片段中，定义了一个函数 foo2，并且在它的函数体中，先给一个名为 bar 的变量赋值为 0 。此时，变量还没有被声明。在第二行，才实际声明了变量 bar 和它的类型。在最后一行，使用 alert 函数显示变量 bar 的值。

### 立即调用函数

立即调用函数（IIFE）是一种设计模式，使用函数作用域作为一个词法作用域。IIFE 可以被用于防止全局作用域中的变量提升导致的污染。举例如下：

```ts
var bar = 0; // 全局的
(function () {
    var foo: number = 0 // 在函数作用域中
    bar = 1  // 在全局作用域中
    console.log(bar) // 1
    console.log(foo) // 0
  })()

console.log(bar) // 1
console.log(foo) // 错误
```

上述例子中，使用 IIFE 包装了两个变量的声明（foo 和 bar）。foo 变量作用于 IIFE 函数中并且在全局作用域中不可用，这解释了为什么当我们尝试在最后一行访问它的时候会产生一个错误。

也可以给 IIFE 传递一个变量，以便更好地控制在作用域之外创建的变量。

```ts
var bar = 0; // 全局的
(function (global) {
    var foo: number = 0 // 在函数作用域中
    bar = 1  // 在全局作用域中
    console.log(global.bar) // 1
    console.log(foo) // 0
  })(this)

console.log(bar) // 1
console.log(foo) // 错误
```

这一次，因为没有在 IIFE 中调用 this 操作符，所以把指向全局作用域的 this 操作符作为唯一的参数传递给了 IIFE。在 IIFE 中，this 操作符传递来的参数称为 global，我们可以更好地控制全局作用域中声明的 bar 变量，而不是 foo 变量。

此外，IIFE 允许我们访问公开方法，隐藏函数内的私有变量：

```ts
class Counter {
  private _i:number
  constructor() {
    this._i = 0
  }
  get():number {
    return this._i
  }
  set(val: number): void {
    this._i = val
  }
  increment(): void {
    this._i ++
  }
}

var counter = new Counter()
console.log(counter.get()) // 0
counter.set(2)
console.log(counter.get()) // 2
counter.increment()
console.log(counter.get()) // 3
console.log(counter._i) // 错误 _i 为私有属性
```

- 通常约定，TS 和 JS 开发者使用下划线开始的变量名作为私有变量名。

定义了一个名为 Counter 的类，它有一个数字类型的私有属性 _i。这个类也有 get 和 set 方法，用来设置和获取这个私有属性 _i 的值。还创建了 Counter 类的实例并调用了 set 、get 和 increment 方法来观察代码是否如设想般正常工作。如果尝试访问 Counter 类实例的 _i 属性，将得到一个错误，因为这个属性是私有的。

编译代码得到：

```js
var Counter = /** @class */ (function () {
    function Counter() {
        this._i = 0;
    }
    Counter.prototype.get = function () {
        return this._i;
    };
    Counter.prototype.set = function (val) {
        this._i = val;
    };
    Counter.prototype.increment = function () {
        this._i++;
    };
    return Counter;
}());
```

生成的 JS 代码在大部分场景下都能完美运行，但如果在浏览器内执行这段代码，创建一个 Counter 的实例并且访问它的 _i 属性，也不会遇到任何错误，因为 TS 不会生成运行时的私有属性。有时候需要编写在运行时拥有私有变量的函数，比如，假设要发布一个 JS 开发者使用的库，可以使用 IIFE 来模拟允许公共地访问一个方法，但在函数内部有一个私有的值：

```ts
var Counter = (function () {
  var _i:number = 0
  function Counter() {

  }
  Counter.prototype.get = function (){
    return _i
  }
  Counter.prototype.set = function (val: number){
    _i = val
  }
  Counter.prototype.increment = function () {
    _i++
  }
  return Counter
})()

var a = new Counter()
console.log(a.get())  // 0
a.set(2) 
console.log(a.get())  // 2
a.increment()
console.log(a.get())  // 3
console.log(a._i)     // undefined
```

在上面例子中，所有的代码都跟 TS 生成的 JS 代码类似，除了 _i 并不是 Counter 类的属性，而是一个在 Counter 闭包内的变量。

- 闭包的职责是引用自由变量。换句话说，函数定义的位置所在的闭包会记住它所在的环境（作用域内的变量）
- 在一些场景下，对作用域和闭包进行精确的控制，代码会和编译后的JS很像。但记住，只要编写的组件是被其他TS组件使用的，就不需要为实现运行时私有属性而烦恼。

### 范型

DRY原则（don't repeat yourself）旨在减少各种类型的信息重复。现在来看下什么是范型函数，并理解它是如何帮助遵守 DRY 原则的。

可以使用范型来避免代码重复。范型编程是一种程序语言的风格，它允许程序员使用以后才会定义的类型。我们将编写一个名为 getEntities 的范型函数，它接受两个参数：

```ts
function getEntities<T>(url: string, cb: (list : T[]) => void):void {
}
```

在函数名后面增加一对角括号来表明这是一个范型函数。如果角括号内是一个字符 T，它表示一个类型。函数的第一个参数是字符串类型的url，第二个参数是函数类型的cb，它接受一个 T 类型的参数作为唯一的参数。

### tag 函数和标签模板

可以使用 tag 函数扩展和修改模板字符串的行为。在模板字符串上应用一个 tag 函数时，这个模板字符串就变成了标签模板。

将实现一个名为 htmlEscape 的 tag 函数。要使用 tag 函数，必须在 tag 函数后紧跟一个模板字符串：

一个标签模板必须返回一个字符串，并接受下面的参数：

- 第一个参数是一个数组，它包含了模板字符串中所有的静态字面量
- 剩余的参数是模板字符串中所有的变量

`tag(literals: string[], ...values: any[]): string`

```ts
var html = htmlEscape `<h1>${name}${username}</h1>`

function htmlEscape(literals, ...placeholders) {
  let result = ''
  for (let i = 0; i < placeholders.length; i++) {
    result += literals[i]
    result += placeholders[i]
      .replace(/&/g, '$amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
  }
  result += literals[literals.length - 1]
  return result
}
```

上面的函数逐字迭代字符串和值来确保所有的 HTML 代码被正确转义，防止代码注入攻击。

使用 tag 函数最大的好处是它允许我们创建一个自定义的模板字符串处理器。

### 回调和高阶函数

在 TS 中，函数可以作为参数传给其他函数。被传递给其他函数的函数叫做回调。函数也可以被另一个函数返回。那些接受函数为参数或返回另一个函数的函数被称为高阶函数。回调通常被用在异步函数中：

```ts
var foo = function () {
    // 回调
    console.log('foo');
};
function bar(cb) {
    // 高阶函数
    console.log('bar');
    cb();
}
bar(foo); // 输出 bar 然后 输出 foo
```

### 箭头函数

在 TS 中，可以使用 function 表达式或者箭头函数定义一个函数。箭头函数是 function 表达式的缩写，并且这种词法会在其作用域内绑定 this 操作符。

在 TS 中，this 操作符的行为和其他语言有一点不一样。当在 TS 中定义一个类的时候，可以使用 this 指向这个类自身的属性。看一个例子：

```ts
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
  greet() {
    console.log(`My name is ${this.name}`)
  }
}

let test = new Person('Test')
test.greet()
```

定义了一个 Person 类，并包含了一个名为 name 的字符串类型的属性。

这个类有一个构造函数和一个叫做 greet 的方法。可以新建一个名为 test 的实例，并调用 greet 方法，它在内部使用 this 操作符访问 test 的 name 属性。在 greet 方法内部，this 操作符指向装载了 greet 方法的对象。

必须谨慎使用 this 操作符，因为在一些场景下它将会指向错误的值：

```ts
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
  greet() {
    console.log(`My name is ${this.name}`)
  }
  greetDelay(time: number) {
    setTimeout(function () {
      console.log(`My name is ${this.name}`)
    }, time)
  }
}

let test = new Person('Test')
test.greet()
test.greetDelay(1000)
```

在 greetDelay 中实现了一个和 greet 方法几乎相同的功能。但这个方法接受一个名为 time 的参数，它用来延迟问候信息的发出。

为了延迟问候消息，使用了 setTimeout 函数和一个回调函数。当定义了一个异步函数时（包含回调），this 关键字就会改变它指向的值，指向匿名函数。

箭头函数表达式的词法会绑定 this 操作符。这意味着可以增加函数而不用担心 this 的指向。现在将上面例子中的 function 表达式替换成箭头函数：

```ts
class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
  greet() {
    console.log(`My name is ${this.name}`)
  }
  greetDelay(time: number) {
    setTimeout( () => {
      console.log(`My name is ${this.name}`)
    }, time)
  }
}

let test = new Person('Test')
test.greet()
test.greetDelay(1000)
```

通过使用箭头函数，可以保证 this 操作符指向的是 Person 的实例而不是 setTimeout 的回调函数。

下面代码是 TS 编译生成的。当编译箭头函数时，TS 编译器会生成一个 this 的别名，名为 _this。这个别名用来确保 this 指向的是正确的对象。

```js
var Person = /** @class */ (function () {
    function Person(name) {
        this.name = name;
    }
    Person.prototype.greet = function () {
        console.log("My name is " + this.name);
    };
    Person.prototype.greetDelay = function (time) {
        var _this = this;
        setTimeout(function () {
            console.log("My name is " + _this.name);
        }, time);
    };
    return Person;
}());
var test = new Person('Test');
test.greet();
test.greetDelay(1000);
```

### 回调地狱

回调的使用可能会导致称为回调地狱的维护性问题。

- 让代码难以理解
- 让代码难以维护（重构、重用等）
- 让异常处理更加困难

### promise

promise 背后最主要的思想是对异步操作结果的一个承诺。一个 promise 一定是以下几种状态之一。

- pending：promise 的初始化状态
- fulfilled：代表异步操作成功的 promise 状态
- rejected：代表异步操作失败的 promise 状态

当一个 promise 处于 fulfilled 或 rejected 状态后，它的状态就永远不可更改了。看一下 promise 的基本语法：

```ts
function foo(value) {
  return new Promise((fulfill, reject) => {
    try {
      fulfill(value)
    }catch (e) {
      reject(e)
    }
  })
}

foo().then(function (value) {
  console.log(value)
}).catch(function (e) {
  console.log(e)
})
```

- 这里的 try...catch 语句只是为了展示如何 fulfill 和 reject 一个 promise。在 Promise 函数内部，并不需要 try...catch 语句，因为 promise 会在有异常抛出的时候自动进入 rejected 状态。
- 上面代码声明了一个名为 foo 的函数，它返回一个 promise。一个 promise 包含了一个名为 then 的方法，它接受一个函数，在 promise 被 fulfilled 后调用。promise 还提供了一个名为 catch 的方法，它在 promise 被 rejected 之后调用。

使用 promise 可以在 render 方法中更好的控制执行流程。

- 并行：异步任务将会并行执行
- 串行：一组任务串行，前一个任务完成后不会传参给后一个任务
- 瀑布流：一组任务串行，每一个任务会将结果传到下一个任务中。这个实现在任务互相依赖时非常有用
- 混合：这是一种并行、串行和瀑布流的任意组合实现

### 生成器

如果在 TS 中调用一个函数，可以肯定一旦这个函数开始运行，在它运行完成之前其他代码都不能运行。然而，一种新的函数可能会在函数执行的过程中将这个函数暂停一次或多次，并在随后恢复它的运行，而且可以让其他代码在暂停的过程中运行，在 TS 何 ES6 中新型函数被称为生成器。

一个生成器代表了一个值的序列。生成器对象的接口只是一个迭代器，可以调用 next() 函数使它产出结果。

可以使用 function 关键字后面跟着一个星号定义一个生成器的构造函数。yield 关键字被用来暂停函数的执行并返回一个值：

```ts
function *foo() {
  yield 1
  yield 2
  yield 3
  yield 4
  return 5
}

let a = new foo()
a.next() // { value: 1, done: false }
a.next() // { value: 2, done: false }
a.next() // { value: 3, done: false }
a.next() // { value: 4, done: false }
a.next() // { value: 5, done: true }
a.next() // { value: undefined, done: true }
```

这个迭代器有 5 个步骤。第一次调用 next() 的时候，函数会执行到第一个 yield 的位置，并且它会返回值1并且停止运行，直到 next() 再次被调用。现在可以终止函数的执行了。可以像下面这样编写一个无限循环而不会导致栈溢出：

```ts
function *foo() {
  let i = 1
  while (true) {
    yield i++
  }
}

let a = new foo()
a.next() // { value: 1, done: false }
a.next() // { value: 2, done: false }
a.next() // { value: 3, done: false }
a.next() // { value: 4, done: false }
a.next() // { value: 5, done: false }
a.next() // { value: 6, done: false }
a.next() // { value: 7, done: false }
```

生成器给了我们以同步的方式编写异步代码的可能性，只要我们在异步事件发生的时候调用生成器的 next() 方法就能做到这一点。

### 异步函数—— async 和 await

一个异步函数是在异步操作中被调用的函数。开发者可以使用 await 关键字等待异步结果的到来而不会阻塞程序的执行。

当编译目标是 ES6 时，异步函数将会被 promise 实现，编译目标是 ES5 和 ES3 时会使用 promise 的兼容版本实现。

与使用 promise 相比，使用异步函数可以显著提高程序的可读性，在技术上使用 promise 可以达到和同步函数同样的效果：

```ts
let p:Promise<number>
async function fn():Promise<number> {
  let i = await p
  return 1 + i
}
```

上面代码声明了一个名为 p 的 promise，这个 promise 将会等待被执行。在等待期间，程序并不会被阻塞，因为是在一个名为 fn 的异步函数中等待它。可以看到，fn 函数前面有一个 async 关键字，这将会对编译器指明这是一个异步函数。

在函数内部，await 关键字被用来暂停代码执行，直到 p 被 fulfilled。可以看到，这个语法更有语义并更加简洁。

### SOLID 原则

- 单一职责原则（SRP）
  - 表明软件组件（函数、类、模块）必须专注于单一的任务（只有单一的职责）
- 开/闭原则（OCP）
  - 表明软件设计时必须时刻考虑到（代码）可能的发展（具有扩展性），但是程序的发展必须最少的修改已有的代码（对已有的修改封闭）
- 里氏替换原则（LSP）
  - 表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。在替换完成后，不需要其他额外的工作程序就能像原来一样运行
- 接口隔离原则（ISP）
  - 表明我们应该将那些非常大的接口（大而全的接口）拆分成一些小的更具体的接口（特定客户端接口），这样客户端就只需要关心它们需要用到地接口
- 依赖反转原则（DIP）
  - 表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念

### 类

```ts
class Person {
  public name: string
  public surname: string
  public email: string
  constructor(name: string, surname: string, email: string) {
    this.email = email
    this.name = name
    this.surname = surname
  }
  greet() {
    console.log('Hello')
  }
}

let a = new Person('xcr', 'xcr', 'xcr@xcr.com')
```

用类去描述一个对象或者实例。一个类由名字、属性和方法组成。上面的例子类型为 Person，包含三个属性（name、surname 和 email）和两个方法（constructor 和 greet）。类的属性通常用来描述对象的特征，方法通常用来描述对象的行为。

constructor 是一个特殊的方法，在用 new 关键字创建一个类的实例的时候被用到。声明了一个变量 a ，用来存储 Person 类的实例。new 关键字使用了 Person 类的constructor 方法返回一个类型为 Person 的对象。

一个类需要遵循单一职责原则。在上面代码中，Person 类包含了它所有的特性和行为。现在，添加一些验证 email 的逻辑：

```ts
class Person {
  public name: string
  public surname: string
  public email: string
  constructor(name: string, surname: string, email: string) {
    this.name = name
    this.surname = surname
    if (this.validateEmail(email)) {
      this.email = email
    }else {
      throw new Error('Invalid email')
    }
  }
  greet() {
    console.log('Hello')
  }
  validateEmail(email) {
    let re = /\S+@\S+\.\S+/
    return re.test(email)
  }
}
```

当一个类不遵循 SRP，知道了太多的事情（拥有太多属性）或做了太多事情（拥有太多方法），称这种对象为 God 对象。这里的 Person 对象就是一个 God 对象，因为增加了一个和 Person 类的行为并无关联的 validateEmail 方法。

决定一个属性或方法能不能成为一个类的一部分，在某种意义上是一种主观的抉择。如果花一点时间分析和选择，就可以找到更好的类的设计方法。

可以通过声明一个 Email 类重构 Person 类，负责 Email 验证并作为 Person 类的一个属性。

```ts
class Email {
  public email: string
  
  constructor(email: string) {
    if (this.validateEmail(email)) {
      this.email = email
    } else {
      throw new Error('Invalid email')
    }
  }

  validateEmail(email: string) {
    let re = /\S+@\S+\.\S+/
    return re.test(email)
  }
}
```

现在有了一个 Email 类，可以把验证代码从 Person 类中移除，然后更新 email 属性，将 string 替换为 Email 对象：

```ts
class Person {
  public name: string
  public surname: string
  public email: Email

  constructor(name: string, surname: string, email: Email) {
    this.name = name
    this.surname = surname
    this.email = email
  }

  greet() {
    console.log('Hello')
  }
}
```

确保每个类都只有单一的职责，可以让我们更容易地看出一个类做了哪些事情、如何去扩展/改进它，将来可以通过提高 Person 和 Email 类的抽象等级来改进它们。例如，当使用 Email 类时，不需要意识到其中 validateEmail 方法地存在，那么这个方法在 Email 外部就是不可见的，这样的话，Email 类就更容易理解。

当提升一个对象的抽象等级时，可以说成是在封装这个对象的数据和行为，封装也被称为信息隐藏。比如，Email 类允许我们使用 Email 而不需要关心 Email 验证，因为这个类已经处理了这些事情。可以通过访问修饰符（private 或 public），将 Email 类上所有需要抽象地属性和方法标记为私有：

```ts
class Email {
  private readonly email: string

  constructor(email: string) {
    if (this.validateEmail(email)) {
      this.email = email
    } else {
      throw new Error('Invalid email')
    }
  }

  private validateEmail(email: string) {
    let re = /\S+@\S+\.\S+/
    return re.test(email)
  }

  get():string {
    return this.email
  }
}
```

然后可以直接使用 Email 类而不需要考虑任何形式的验证：

```ts
let email = new Email('xcr@xcr.com')
```

### 接口

遵循 SOLID 原则可以帮助提高代码质量，可在大型项目中编写出更好的代码。TS 提供了接口特性来支持 SOLID 原则的面向对象的代码。

在传统的面向对象概念中，一个类可以扩展另一个类，也可以实现一个或多个接口。一个接口可以实现一个或多个接口但是不能扩展另一个类或接口。接口定义：

- 在面向对象的语言中，术语 interface 经常被用来定义一个不包含数据和逻辑代码但用函数签名定义了行为的抽象类型。

实现一个接口可以被看作是签署了一份协议。接口好比是协议，当我们签署它（实现它）时，必须遵守它的规则。接口的规则是方法和属性的签名，必须实现它们。

在 TS 中，接口并不是严格遵守上面提到的定义，在 TS 中主要有两点不同：

- 接口可以扩展其他接口或者类
- 接口可以定义数据和行为而不只是行为

### 关联

那些有联系但它们的对象有独立的生命周期，并且没有从属关系的类之间的关系，称为之关联。

多个学生可以与一个老师有关联联系，一个学生也可以与多个老师有关联关系，但他们都有自己的生命周期（都可以被独立的创建和删除）。所以当老师离开学校时，不必删除任何学生，学生们离开学校是也不必删除任何老师。

![image-20220329193959696](https://cdn.jsdelivr.net/gh/itxcr/oss/picture_bed/202203291940804.png)

### 聚合

将那些拥有独立生命周期，但是有从属关系，并且子对象不能从属于其他对象的关系称为聚合。

一块单独的手机电池可以属于一台手机，但是假如一台手机停止工作了，可以将它从数据库中删除，但电池并不需要删除，因为它可能还是可以用的。所以在聚合关系中，即使是有从属关系，但对象间依然有独立的生命周期。

![image-20220329194501907](https://cdn.jsdelivr.net/gh/itxcr/oss/picture_bed/202203291945964.png)

### 组合

指那些没有独立生命周期，父对象被删除后子对象也被删除的对象间的关系。

一个问题可以有多个答案，并且一个答案不可以属于多个问题。如果删除了问题，答案将会被自动删除。

生命周期依赖其他对象的对象也被称作弱实体。

![image-20220329195118294](https://cdn.jsdelivr.net/gh/itxcr/oss/picture_bed/202203291951342.png)

有时候决定使用关联、聚合还是组合是一个复杂的过程。导致这一困难的原因是聚合和组合是关联的子集，这意味着它们属于关联的特殊情况。

![image-20220329195250084](https://cdn.jsdelivr.net/gh/itxcr/oss/picture_bed/202203291952148.png)

### 继承

面向对象编程最重要的基本功能之一就是可以扩展已有的类，这个功能被称之为继承。它允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以包含父类中没有的属性和方法。

```ts
class Person {
  public name: string
  public surname: string
  public email: string
  constructor(name: string, surname: string, email: string) {
    this.name = name
    this.surname = surname
    this.email = email
  }
  greet() {
    console.log('Hello')
  }
}
```

一旦有了一个父类，就可以使用保留字 extends 扩展它

```ts
class Teacher extends Person {
  teach() {
    console.log('教书')
  }
}
```

向 Teacher 类添加了一个新的 teach 方法。如果创建 Person 和 Teacher 的实例，会看到它们将会共享所有的属性和方法。除了 Teacher 类中的 teach 方法，这个方法只在 Teacher 类的实例中存在：

```ts
let teacher = new Teacher('xcr', 'xcr', new Email('xcr@xcr.com'))
let me = new Person('test', 'test', new Email('test@test.com'))
me.greet()
teacher.greet()
teacher.teach()
me.teach() // property 'teach' does not exist on type 'Person'.
```

有时希望子类能提供父类中同名方法的特殊实现。可以使用保留字 super 达到这个目的。试想一下，需要增加一个属性列出老师教的科目并且想通过 Teacher 类的构造函数初始化这个属性。可以在子类的构造函数中使用 super 关键字引用父类的构造函数，也可以在扩展已有方法的时候使用 super 关键字，比如 greet 方法。在面向对象语言中，这种允许子类提供父类已有方法的特殊实现的功能被称作方法重写。

```ts
class Teacher extends Person {
  public subjects: string[]
  constructor(name: string, surname: string, email: Email, subjects: string[]) {
    super(name, surname, email);
    this.subjects = subjects
  }

  greet() {
    super.greet()
    console.log('开示教书' + this.subjects)
  }
  teach() {
    console.log('教书')
  }
}
let teacher = new Teacher('xcr', 'xcr', new Email('xcr@xcr.com'), ['数学', '英语'])
```

可以声明一个新的类继承一个已经继承了别的类的类。

```ts
class SchoolPrincipal extends Teacher {
  manageTeachers() {
    console.log('我们需要帮助学生变得更好')
  }
}
```

当创建一个 SchoolPrincipal 类的实例时，将可以访问它的父类的所有方法和属性（SchoolPrincipal、Teacher、Person）：

```ts
let principal = new SchoolPrincipal('testP', 'P', new Email('p@p.com'), ['数学', '物理'])
principal.greet()
principal.teach()
principal.manageTeachers()
```

但是，不推荐有过多层级的继承。一个位于继承树上很深层级的类开发、测试和维护，在某种程度上非常复杂。不幸的是，在不确定是否应该增加继承树深度（DIT）的时候，并没有一个具体的规则进行指导。

应该将继承用来减少程序的复杂度而不是起到相反的效果。应该保证 DIT 在 0-4 之间，因为大于 4 时将损害封装性并增加复杂度。

### 混合

有时候，会认为声明一个同时继承两个或多个类（多重继承）的类是一个好想法。

下面这个例子不会为方法加入任何代码，避免因为这些方法而分心，而是将注意力集中在继承树上：

```ts
class Animal {
  eat() {
      // ...
  }
}
```

从声明一个 Animal 类开始，它只有一个 eat 方法。现在声明两个新的类：

```ts
class Mammal extends Animal {
  breathe() {
    // ...
  }
}

class WingedAnimal extends Animal {
  fly() {
    // ...
  }
}
```

声明了两个新类，分别叫 WingedAnimal（飞行动物） 和 Mammal（哺乳动物），这两个类都继承自 Animal 类。

现在类已经准备好了，现在将尝试着实现一个名为 Bat（蝙蝠）的类，蝙蝠既是哺乳动物又是飞行动物——创建一个既继承 Mammal 类又继承 WingedAnimal 类的 Bat 看起来顺理成章。然而，当我们试图这么做的时候，会遇到一个编译错误:

```ts
class Bat extends WingedAnimal, Mammal {
  // ...
}
```

出现这个编译错误是因为 TS 不支持多重继承，这意味着一个类只能继承自一个类。像 C# 或者 TS 这样的程序语言的设计者决定不支持多重继承，是因为这个特性会潜在的增加程序的复杂性。

在一些情况下，一个类的继承图会呈现为钻石状，如下图所示。这种类型的类的继承图可能会导致我们遇到被称作钻石问题的设计问题。

![image-20220331142115645](https://cdn.jsdelivr.net/gh/itxcr/oss/picture_bed/202203311421725.png)

假如调用只存在于继承树上其中一个类中的方法的时候，不会遇到问题：

```ts
let a = new Bat()
a.fly()
a.eat()
a.breathe()
```

钻石问题出现在当调用 Bat 类中的父类中都存在的方法的时候，哪一个父类的方法被调用是不清楚的或者说是存在歧义的。当增加一个 move 方法到 Mammal 类和 WingedAnimal类上并试图在 Bat 类的实例上调用它时，就会遇到一个歧义调用错误。

现在知道了多重继承为什么会导致潜在的危险，所以引入了混合（Mixin）特性。混合是多重继承的替代，但是这个功能有一些限制。

```ts
class Mammal  {
  breathe() {
    console.log('breathe')
  }
}

class WingedAnimal {
  fly() {
    console.log('fly')
  }
}

class Bat implements Mammal, WingedAnimal  {
  breathe: () => string
  fly: () => string
}
```

Bat 类增加了一些重要的东西，使用保留关键字 implements （与 extends 相反）表明 Bat 会实现所有 Mammal 和 WingedAnimal 类中声明的功能。还增加了所有 Bat 类会实现的函数的签名。

需要将下面的函数复制到代码中以便应用混合的效果：

```ts
function applyMixins(derivedCtor: any, baseCtors: any[]) {
  baseCtors.forEach(baseCtor => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
      if (name !== 'constructor') {
        derivedCtor.prototype[name] = baseCtor.prototype[name]
      }
    })
  })
}
```

- 上面这个函数是一个非常有名的范式

这个函数会迭代所有父类的属性（存储到 baseCtors 数组中），然后将它们的实现复制到子类中（derivedCtor）。

只需要在程序中声明一次这个函数，然后就可以像下面这样使用它：

```ts
applyMixins(Bat, [Mammal, WingedAnimal])
```

随后子类 （Bat） 会包含它的两个父类（Mammal 和 WingedAnimal）的所有属性和方法。

```ts
let a = new Bat()
a.fly() // fly
a.breathe() //breathe
```

使用混合有一些限制，第一个限制就是只能在继承树上继承一级的方法和属性。第二个限制是，如果两个或更多的父类包含了同名的方法，那么只会继承传入 applyMixins 方法中的 baseCtors 数组中最后一个类中的该方法。

```ts
class Animal {
  eat(): string {
    console.log('eat')
    return ''
  }
}
```

然后声明 Mammal 和 WingedAnimal 类，这次会继承 Animal 类：

```ts
class Mammal extends Animal{
  breathe(): string {
    console.log('breathe')
    return ''
  }
  move(): string {
    console.log('move1')
    return ''
  }
}

class WingedAnimal extends Animal{
  fly(): string {
    console.log('fly')
    return ''
  }
  move(): string {
    console.log('move2')
    return ''
  }
}
```

随后声明 Bat 类但命名为 Bat1。这个类会实现 Mammal 和 WingedAnimal 类：

```ts
class Bat1 implements Mammal, WingedAnimal  {
  eat: () => string
  breathe: () => string
  fly: () => string
  move: () => string
}
```

准备好调用 applyMixins，此时 Mammal 在 WingedAnimal 前面：

```ts
applyMixins(Bat1, [Mammal, WingedAnimal])
```

现在可以创建一个 Bat1 的实例，然后可以观察到，由于第一个限制，eat 方法并没有从 Animal 类上继承下来：

```ts
let a = new Bat1()
a.eat() // 错误：不是一个函数
```

所有父类的方法都被正确的继承，除了 move 方法，由于第二条限制，只有最后一个传给 applyMixins 的父类的同名实现被继承，这里 move 的实现是继承自 WingedAnimal 类的。

```ts
a.breathe() // breathe
a.fly()  // fly
a.move()  // move2
```

为了确定这一点，看一下调用 applyMixins  的时候调换父类的顺序之后的结果：

```ts
class Bat1 implements WingedAnimal, Mammal {
  eat: () => string
  breathe: () => string
  fly: () => string
  move: () => string
}

applyMixins(Bat1, [WingedAnimal, Mammal])

let a = new Bat1()
a.breathe()  // breathe
a.fly()  // fly
a.move()  // move2
a.eat()  // 错误：不是一个函数
```

### 范型类

```ts
class User {
    public name: string
    public password: string
}
```

声明了一个 User 类，它包含两个属性：name 和 password。我们将声明一个非范型的 NotGenericUserRepository 类。这个类通过它的构造函数接受一个 URL 并且有一个名为 getAsync 的方法。getAsync 方法通过 AJAX 请求一个用户列表并储存在一个 JSON 文件中：

```ts
class NotGenericUserRepository {
  private _url: string

  constructor(url: string) {
    this._url = url
  }

  public getAsync() {
    return Q.Promise((resolve: (users: User[]) => void, reject) => {
      $.ajax({
        url: this._url,
        type: "GET",
        dateType: "json",
        success: (data) => {
          let users = <User[]>data.items
          resolve(users)
        },
        error: e => {
          reject(e)
        }
      })
    })
  }
}
```

一旦声明了 NotGenericUserRepository ，就可以创建它的实例并调用 getAsync 方法：

```ts
let notGenericUserRepository = new NotGenericUserRepository('./user.json')
notGenericUserRepository.getAsync()
  .then(function (users: User[]) {
    console.log(users)
  })
```

如果还需要请求一个不同于 User 的其他类型实例的表，最终会重复写很多代码。想象一下，还需要请求一个会议的对话列表，会创建一个名为 Talk 的实例和一个几乎完全相同的类：

```ts
class Talk {
  public title: string
  public description: string
  public language: string
  public url: string
  public year: string
}

class NotGenericTalkRepository {
  private _url: string
  constructor(url: string) {
    this._url = url
  }
  
  public getAsync() {
    return Q.Promise((resolve: (talks: Talk[]) => void, reject) => {
      $.ajax({
        url: this._url,
        type: "GET",
        dateType: "json",
        success: (data) => {
          let talks = <Talk[]>data.items
          resolve(talks)
        },
        error: e => {
          reject(e)
        }
      })
    })
  }
}
```

如果实例种类的数量增加，我们将会继续写重复代码。可能会想到用 any 类型避免这个问题，但这样就失去了 TS 在编译器中提供的类型检查的保护。更好的方式是创建一个范型类：

```ts
class GenericRepository<T>{
  private _url: string
  constructor(url: string) {
    this._url = url
  }
  
  public getAsync() {
    return Q.Promise((resolve: (entities: T[]) => void, reject) => {
      $.ajax({
        url: this._url,
        type: "GET",
        dateType: "json",
        success: (data) => {
          let list = <T[]>data.items
          resolve(list)
        },
        error: e => {
          reject(e)
        }
      })
    })
  }
}
```

这些代码除了范型以外与 NotGenericTalkRepository 完全相同。移除了具体的 User 和 Talk 类型，用范型 T 取代它。现在可以使用一行代码并且不需要重复地声明任意多的实例：

```ts
let userRepository = new GenericRepository<User>('./users.json')
userRepository.getAsync()
  .then((users: User[]) => {
    console.log(users)
  })

let talkRepository = new GenericRepository<Talk>('./talks.json')
talkRepository.getAsync()
  .then((talks: Talk[]) => {
    console.log(talks)
  })
```

### 范型约束

有时候，可能会需要约束范型类。如上述例子中的范型类，有一个新的需求：需要增加一些变更来验证通过 AJAX 请求到的数据并且只有验证有效后返回。

- 一个可行的方案是在范型类或函数内使用 typeof 操作符来验证参数范型 T 的类型：

```ts
success: (data) => {
  let list: T[]
  let items = <T[]>data.items
  for (let i = 0; i < items.length; i++) {
    if (items[i] instanceof User) {
      // User 相关
    }
    if (items[i] instanceof Talk) {
      // Talk 相关
    }
  }
  resolve(list)
},
```

问题是每增加一个新的有效实例，就必须修改 GenericRepository 类增加额外的逻辑。不会将验证逻辑加入到 GenericRepository  类中，因为一个范型类不应知道范型的类型。

一个更好的解决方案是要给获取的实例增加一个 isValid 方法，它在实例验证通过的时候返回 true：

```ts
success: (data) => {
  let list: T[]
  let items = <T[]>data.items
  for (let i = 0; i < items.length; i++) {
    if (items[i].isValid()) { // error
      // ...
    }
  }
  resolve(list)
},
```

第二种实现方式遵循 SOLID 原则中的开/闭原则。可以在 GenericRepository  正常工作的情况下增加一个新的实例（对扩展开放），但是不需要额外的修改代码（对已有的修改封闭）。这种实现的唯一问题是，如果在 GenericRepository   中尝试调用实例的 isValid 方法，会遇到一个编译错误。

会遇到这个错误是因为允许 GenericRepository  与任意类型的实体一起使用，但不是所有的类型都有 isValid 方法。幸运的是，这个问题可以通过范型约束轻易解决。范型约束会约束允许作为范型参数中 T 的类型。将声明一个范型约束，这样的话只有实现了 ValidatableInterface 接口的类型可以用于这个范型方法。

从一个接口声明开始：

```ts
interface ValidatableInterface {
  isValid(): boolean
}
```

接下来实现这个接口。在这个例子中，必须实现 isValid 方法：

```ts
class User implements ValidatableInterface {
  public name: string
  public password: string

  public isValid(): boolean {
    // 判断内容
    return true;
  }
}

class Talk implements ValidatableInterface {
  public title: string
  public description: string
  public language: string
  public url: string
  public year: string

  isValid(): boolean {
    // 判断内容
    return true;
  }

}
```

现在，声明一个范型仓库并且为它加上范型约束，然后只有实现了 ValidatableInterface 的类型可以作为范型参数 T：

```ts
class GenericRepositoryWithConstraint<T extends ValidatableInterface> {
  private _url :string
  constructor(url: string) {
    this._url = url
  }
  public getAsync() {
    return Q.Promise((resolve: (entities: T[]) => void, reject) => {
      $.ajax({
        url: this._url,
        type: "GET",
        dateType: "json",
        success: (data) => {
          let list: T[]
          let items = <T[]>data.items
          for (let i = 0; i < items.length; i++) {
            if (items[i].isValid()) {
              list.push(items[i])
            }
          }
          resolve(list)
        },
        error: e => {
          reject(e)
        }
      })
    })
  }
}
```

- 即使在使用接口的时候，在上面例子中也可以使用 extends 关键字而不是 implements 关键字去声明范型约束。这样做并无特殊原因，这就是 TS 范型约束语法的工作方式。

可以创建想要的任意多的仓库：

```ts
let userRepository = new GenericRepositoryWithConstraint<User>('./user.json')
userRepository.getAsync()
  .then(function (users: User[]) {
    console.log(users)
  })
let talkRepository = new GenericRepositoryWithConstraint<Talk>('./talks.json')
talkRepository.getAsync()
  .then(function (talks: Talk[]) {
    console.log(talks)
  })
```

如果尝试使用一个没有实现 ValidatableInterface 的类作为范型参数 T，就会得到一个编译错误。

### 在范型约束中使用多重类型

当声明范型约束的时候，只能关联一种类型。想象一下，有一个范型类需要被约束，它只允许使用实现了以下两个接口的类型：

```ts
interface IMyInterface {
  doSomething()
}

interface IMySecondInterface {
  doSomethingElse()
}
```

可能会想到下面这样的定义范型约束：

```ts
class Example<T extends IMyInterface, IMySecondInterface> {
  private genericProperty: T
  useT() {
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse() // 错误
  }
}
```

然而，这段代码会抛出一个编译错误。我们不能在定义范型约束的时候指定多个类型。然而，可以通过将 IMyInterface、 IMySecondInterface 转变成一个超接口来解决这个问题：

```ts
interface IChildInterface extends IMyInterface, IMySecondInterface {}
```

IMyInterface 和 IMySecondInterface 现在都是超接口，因为它们都是 IChildInterface 接口的父接口，可以使用 IChildInterface 来定义范型约束：

```ts
class Example<T extends IChildInterface> {
  private genericProperty: T
  useT() {
    this.genericProperty.doSomething()
    this.genericProperty.doSomethingElse()
  }
}
```

### 范型中 new 操作

要通过范型代码来创建新的对象，需要声明范型 T 拥有构造函数。这意味着需要像下面这样用 type: { new(): T} 替代 type: T ：

```ts
function factoryNotWorking<T>(): T {
  return new T // 找不到标识 T，编译错误
}

function factory<T>():T {
  let type: {new() : T}
  return new type()
}

let myClass: MyClass = factory<MyClass>()
```

### 遵循 SOLID 原则

如果要遵循 SOLID 原则，接口是最基础的功能之一。

#### 里氏替换原则

里氏替换原则（LSP）表示派生类对象能够替换其基类对象被使用。

将声明一个名为 PersistanceService 的类，它的作用是将一些对象持久化到某种存储中。以声明下面的接口开始：

```ts
interface PersistanceServiceInterface {
  save(entity: any): number
}
```

将在声明 PersistanceServiceInterface 后实现它，使用 cookies 作为存储程序数据的介质：

```ts
class CookiePersitanceService implements PersistanceServiceInterface {
  save(entity: any): number {
    let id = Math.floor((Math.random() * 100) + 1)
    // Cookie 持久化逻辑
    return id
  }
}
```

继续声明一个名为 FavouritesController 的类，它有一个基于 PersistanceServiceInterface 的依赖：

```ts
class FavouritesController {
  private _persistanceService: PersistanceServiceInterface
  constructor(persistanceService: PersistanceServiceInterface) {
    this._persistanceService = persistanceService
  }
  public saveAsFavourite(articleId: number) {
    return this._persistanceService.save(articleId)
  }
}
```

最后可以通过向构造函数传入 CookiePersitanceService 的实例来创建一个 FavouritesController 的实例。

```ts
let favController = new FavouritesController(new CookiePersitanceService())
```

LSP 允许将依赖替换成其他的实现，只要这个实现是基于同一个基类的。所以，假如决定不用 cookie 作为存储介质，而使用 HTML5 本地存储取代它，可以声明一个新的实现：

```ts
class LocalStoragePersitanceService implements PersistanceServiceInterface {
  save(entity: any): number {
    let id = Math.floor((Math.random() * 100) + 1)
    // 本地持久化存储
    return id;
  }
}
```

可以在不需要对 FavouritesController 控制类做任何修改的情况下用它替换：

```ts
let favController = new FavouritesController(new LocalStoragePersitanceService())
```

#### 接口隔离原则

接口被用来声明两个或更多的应用组件间是如何相互操作和交换信息的。这种声明也被称作应用程序接口（API）。上一个例子中，接口是 PersistanceServiceInterface ，它被 LocalStoragePersitanceService 和 CookiePersitanceService 类实现。这个接口也被 FavouritesController 类消费，因此说这个类是 PersistanceServiceInterface API 的客户端。

接口隔离原则（ISP）代表着任何客户端不应强制依赖于它没有使用到的方法。为了遵循 ISP，需要记住，在应用组件内声明 API 时，声明多个针对特定客户端的接口，要好于声明一个大而全的接口。

如果设计一个 API，控制车辆中所有的零件（引擎、收音机、暖气、导航、灯等），可以只用一个通用的接口，它可以控制车辆中的每一个零件：

```ts
interface VehicleInterface {
  getSpeed(): number
  getVehicleType(): string
  isTaxPayed(): boolean
  isLightsOn(): boolean
  isLightsOff(): boolean
  startEngine(): void
  accelerate(): number
  stopEngine(): void
  startRadio(): void
  playCd(): void
  stopRadio(): void
}
```

如果一个类有一个基于 VehicleInterface 的依赖（客户端），但只想使用它的 radio 方法，就会违背 ISP。因为没有任何客户端会被强制依赖它没有使用到的方法。

解决方案是将 VehicleInterface 分离成多个针对客户端的接口，这样类就可以通过只依赖 RadioInterface 接口来遵循 ISP：

```ts
interface VehicleInterface {
  getSpeed(): number
  getVehicleType(): string
  isTaxPayed(): boolean
}

interface LightsInterface {
  isLightsOn(): boolean
  isLightsOff(): boolean
}

interface RadioInterface {
  startRadio(): void
  stopRadio(): void
  playCd(): void
}

interface EngineInterface {
  startEngine(): void
  accelerate(): number
  stopEngine(): void
}
```

#### 依赖反转原则

依赖反转原则（DIP）表示一个方法应该遵从依赖于抽象而不是一个实例。前面实现了 FavouritesController，并且可以不需要对 FavouritesController 做任何修改就能替换 PersistanceServiceInterface 的实现。这种行为成为可能是因为代码遵循 DIP，即：FavouritesController 依赖的是 PersistanceServiceInterface （抽象），而不是 LocalStoragePersitanceService 或 CookiePersitanceService （实现）。

### 命名空间

TS 提供了命名空间特性。命名空间主要用于组织代码。

如果在写一个大型应用，在代码量增加的时候需要引入某种代码组织方案避免命名冲突，并使代码更加容易跟踪和理解。

这时可以用命名空间包裹那些有联系的接口、类和对象。比如，可以将所有的程序数据模型包含在名为 model 的内部模块中：

```ts
namespace app {
  export class UserModel {
    // ...
  }
}
```

当声明一个命名空间时，所有实体部分默认都是私有的，可以使用 export 关键字导出公共部分。

也可以在命名空间内声明另一个命名空间。下面创建一个名为 module.ts 的文件，并加入下面代码：

```ts
namespace app {
  export namespace modules {
    export class UserModule {
      // ...
    }
    export class TalkModule {
      // ...
    }
  }
}
```

上面例子中声明了一个名为 app 的命名空间，在它的内部，又声明了一个名为 modules 的公共命名空间，它有两个公共类：UserModule 和 TalkModule。随后可以在其他的 TS 文件中通过指明命名空间名字进行访问：

```ts
let user = new app.modules.UserModule()
let talk = new app.modules.TalkModule()
```

如果一个内部模块变得太大，它应被分成多个文件来增加可维护性。如果继续上一个例子，可以通过在其他文件中引用 app 给内部模块 app 增加更多内容。

新建一个名为 validation.ts 的文件并加入下面代码：

```ts
namespace app {
  export namespace validation {
    export class UserValidator {
      // ...
    }
    export class TalkValidator {
      // ...
    }
  }
}
```

新建一个名为 main.ts 的文件并加入下面代码：

```ts
/// <reference path = "module.ts" />
/// <reference path = "validation.ts" />
let user = new app.modules.UserModule();
let talk = new app.modules.TalkModule();
let userValidator = new app.validation.UserValidator();
let talkValidator = new app.validation.TalkValidator();
```

在一个单独的 TS 文件中，使用三斜杠 `///` 引用它

- ```ts
  /// <reference path = "module.ts" />
  /// <reference path = "validation.ts" />
  ```

- 输出文件：`pnpm tsc --outFile test.js  main.ts`

即使命名空间 modules 和 validation 在两个不同的文件中，也可以在第三个文件中同时访问到它们。

命名空间可以包含点号。比如，替代在 app 模块中使用嵌套命名空间（validation 和 modules），可以在 validation 和 modules 内部模块名上使用点号：

```ts
namespace app.validation {
  // ...
}

namespace app.modules {
  // ...
}
```

import 关键字可以用在内部模块中，为另一个模块提供别名：

```ts
import TalkValidatorAlias = app.validation.TalkValidator
let talkValidator = new TalkValidatorAlias()
```

一旦声明了命名空间，就可以决定是否将它们分别编译成 JS 文件或者编译合并成单一的 JS 文件。

可以使用 --out 参数将所有的输入文件编译成一个单一的 JS 文件：

`tsc --out output.js input.ts`

编译器会根据文件的引用在输出文件中自动整理好顺序，随后可以使用 HTML 中的 `<script>` 标签引入。

### 模块

TS 也有外部模块或者模块的概念。模块与命名空间相比最主要的区别是，在声明了所有的模块之后，不会使用 `<script>` 标签引入它们，它们通过模块加载器来加载。

模块加载器是在模块加载过程中为我们提供更好控制能力的工具，它能优化加载任务，比如异步加载文件或者轻松合并多个模块到单一的高度优化的文件中。

使用 `<script>` 标签的方式并不被推荐，因为当浏览器发现一个 `<script>` 标签时，它不会使用异步请求加载这个文件。应该尽可能的尝试异步加载文件，因为这样能显著提高 Web 程序的网络性能。

流行的模块加载器：

- RequireJS：RequireJS 使用了一个被称作异步模块定义的语法（AMD）
- Browserify：Browserify 使用的语法被称为 CommonJS。
- SystemJS：SystemJS  是一个通用模块加载器，这意味着它支持所有的模块定义语法（ES6、CommonJS、AMD和UMD）。
- Node.js 也使用 CommonJS 语法。

幸运的是，TS 允许选择在运行环境中使用哪一种模块定义语法（ES6、CommonJS、AMD、UMD、SystemJS 或 UMD）。

可以在编译期使用 --module 标志来表明选择哪一种：

```shell
# 使用 CommonJS
tsc --module commomjs main.ts
# 使用 AMD
tsc --module amd main.ts
# 使用 UMD
tsc --module umd main.ts
# 使用 SystemJS
tsc --module system main.ts
```

与可以选择4种不同的运行时模块定义语法不同，在程序设计阶段只能选择两种模块定义语法：

- 外部模块语法
- ES6 模块语法

重要的是，必须了解，可以在程序设计阶段使用一种模块定义语法（外部模块语法或ES6），在运行时使用另一种模块定义语法（ES6、CommonJS、AMD、UMD 或 SystemJS）。

推荐使用 ES6 模块定义语法，因为它基于最新标准，并且将来可以在设计阶段和运行时都使用这种模块定义语法。

### ES6模块——运行时与程序设计时

定义一个外部模块

```ts
class UserModel {
  
}
export { UserModel }
```

定义了一个外部模块，不需要使用 namespace 关键字，但依然要使用 export 关键字。在模块底部使用了 export 关键字，也可以在 class 前使用这个关键字：

```ts
export class UserModel {

}
```

也可以通过别名输出：

```ts
class UserModel {

}
export { UserModel as User } // UserModel 输出为 User
```

一个 export 声明输出所有的同名定义：

```ts
interface UserModel {
}

class UserModel {
}
export {UserModel} // 输出接口和函数
```

引入一个模块，必须这样使用 import 关键字：

```ts
import {UserModel} from "./main";
```

import 关键字给每一个导入的组件创建一个变量。在上面代码中，变量 UserModel 被声明，并且值为在 main.ts 文件中声明并导出的 UserModel 类的一个引用。

可以使用 export 关键字在一个模块中导出多个实体：

```ts
class UserValidator {
  
}
class TalkValidator {
  
}
export {UserValidator, TalkValidator}
```

并且可以使用 import 关键字从一个模块导入多个实体：

```ts
import {UserValidator, TalkValidator} from "./main";
```

### 外部模块语法——仅在程序设计阶段可用

可以使用 import 关键字来引入一个模块：

```ts
import User = require('./test')
```

上面代码声明了一个新的变量 User。User 变量将使用 test 模块输出的内容作为自身的值。
