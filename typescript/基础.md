### 类型别名

允许使用 type 关键字声明类型别名：

```ts
type PrimitiveArray = Array<string | number | boolean>
type MyNumber = number
type NgScope = ng.IScope
type Callback = () => void
```

### 环境声明

允许在 TypeScript 中创建一个不会被编译到 Javascript 中的变量。这个特性是用来促进与现有 Javascript 代码、DOM（文档对象模型）、BOM（浏览器对象模型）结合而设计的。

有时，我们希望调用一个未被定义的对象上的方法，比如 window 对象上的 console 方法。

当访问 DOM 或 BOM 对象时，我们没有遇到错误，是因为这些对象已经在一个特殊的 Typescript 文件（被称为 声明文件）中被声明了。可以使用 declare 操作符创建一个环境声明。

下面代码中，声明一个被 customConsole 对象实现的接口。然后使用 declare 操作符在作用域中增加一个 customConsole 对象：

```ts
interface ICustomConsole {
    log(arg: string): void
}
declare var cuntomConsole: ICustomConsole
```

然后就可以在没有编译错误的情况下使用 cuntomConsole

`cuntomConsole.log("测试")`

Typescript 默认包含一个名为 lib.d.ts 的文件，它提供了像 DOM 这种 Javascript 内置库的接口声明。

使用 .d.ts 结尾的声明文件，是用来提高 Typescript 对第三方库和像 Node.js 或浏览器这种运行时环境的兼容性的。

### 算数运算符

`+、-、*、/、%、++、——`

### 接口

在 TS 中，可以使用接口来确保类拥有指定的结构

```ts
interface loggerInterface {
  log(arg: any): void
}

class Logger implements loggerInterface {
  log(arg) {
    if (typeof console.log === 'function') {
      console.log(arg)
    }else {
      alert(arg)
    }
  }
}
```

上面定义了一个名为 loggerInterface 的接口，和一个实现了它的 Logger 类。TS 允许使用接口来约束对象。这让我们可以避免很多潜在的小错误：

```ts
interface UserInterface {
  name: string,
  password: string
}

let user: UserInterface = {
  name: '',
  pasword: '' //遗漏错误属性  '{ name: string; pasword: string; }' is not assignable to type 'UserInterface'
}
```

### 命名空间

又称内部模块，被用于组织一些具有某些内在联系的特性和对象。命名空间能够使代码结构更清晰，可以使用 namespace 和 export 关键字，在 TS 中声明命名空间。

```ts
namespace Geometry {
  interface VectorInterface {
  }

  export interface Vector2dInterface {
  }

  export interface Vector3dInterface {
  }

  export class Vector2d implements VectorInterface, Vector2dInterface {
  }

  export class Vector3d implements VectorInterface, Vector3dInterface {
  }
}
const vector2dInstance: Geometry.Vector2dInterface = new Geometry.Vector2d()
const vector3dInstance: Geometry.Vector3dInterface = new Geometry.Vector3d()
```

上面声明了一个包含 Vector2d、Vector3d类和VectorInterface、

Vector2dInterface、Vector3dInterface 接口的命名空间。注意，命名空间内的第一个接口声明前并没有 export 关键字。所以在命名空间外部，访问不到它。

### 综合运用

下面的例子用到了模块、类、函数和类型注解：

```ts
module Geometry {
  export interface Vector2dInterface {
    toArray(callback: (x: number[]) => void): void
    length(): number
    normalize()
  }

  export class Vector2d implements Vector2dInterface {
    private _x: number
    private _y: number

    constructor(x: number, y: number) {
      this._x = x
      this._y = y
    }

    toArray(callback: (x: number[]) => void): void {
      callback([this._x, this._y])

    }

    length(): number {
      return Math.sqrt(this._x * this._x + this._y * this._y)
    }

    normalize() {
      let len = 1 / this.length()
      this._x *= len
      this._y *= len
    }
  }
}
```

```ts
const vector: Geometry.Vector2dInterface = new Geometry.Vector2d(2, 3)
vector.normalize()
vector.toArray((vectorAsArray: number[]) => {
  console.log(vectorAsArray)
})
```

类型检查和智能提示会帮助创建 Vector2d 类的实例，单位化它的值，将其转化为数组。

### 自动化任务工具

自动化任务工具用来自动化地执行开发过程中需要重复进行的任务。这些任务包括编译 Ts 文件、压缩 Js 文件等等。

Gulp 使用的是流，Gulp 插件更倾向于使用代码来描述任务，这使得 Gulp 任务的可读性更高。

安装 Gulp

- `pnpm add gulp -D`

创建一个 `gulpfile.js` ，写完任务后执行 gulp 命令即可执行任务。

### 自动化测试工具

### 函数类型

通过使用可选的类型声明注解来显式声明一个元素的类型：

```ts
function greetNamed(name: string):string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

在上述函数中，定义了参数 name 的类型（string）和返回值类型（string）。有时候不只需要定义函数中元素的类型，还需要定义函数本身的类型。如下：

```ts
let greetUnnamed:(name: string) => string

greetUnnamed = function (name: string): string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

在上述例子中，声明了变量 greetUnnamed 及其类型。greetUnnamed 的类型是一个只包含一个名为 name 的 string 

类型参数、在调用后会返回类型为 string 的函数。在声明了这个变量之后，一个完全符合变量类型的函数被赋值给了它。

也可以声明 greetUnnamed 的类型，并在同一行中将一个函数赋值给它，而不是分割成两行，例如：

```ts
let greedUnnamed:(name: string) => string = function (name: string):string {
  if (name) {
    return `Hi! ${name}`
  }
}
```

如上，之前的代码片段中同样声明了变量 greedUnnamed 和它的类型。我们也可以在同一行中把一个函数赋值给这个变量，被赋值的函数类型必须与变量类型相同。

### 有可选参数的函数

与 JS 不同，调用函数时传参的数量或类型不符合函数中定义的参数要求时，TS 编译器会报错。

```ts
function add(foo: number, bar: number, foobar: number): number {
  return foo + bar + foobar
}
```

上述函数名为 add 并包含三个 number 类型的参数：foo、bar 和 foobar。如果调用这个函数时没有完整地传入三个参数，会得到一个编译错误，提示提供地参数与函数声明中地参数无法匹配。

在一些场景下，我们也许想调用这个函数且不提供所有的参数。TS 提供了一个函数可选参数的特性，可以帮助增加这个函数的灵活性。可以在 TS 中通过在函数参数后追加一个字符 " ? "，指定函数参数是可选的。更新一下前面的函数，将 foobar 参数从必选参数修改为可选参数。

```ts
function add(foo: number, bar: number, foobar?: number): number {
  let result = foo + bar
  if (foobar !== undefined) result += foobar
  return result
}
```

修改后，提供两个或三个参数调用这个函数时，TS 编译器不再抛出错误。

值得注意的是，可选参数必须位于必选参数列表的后面。

### 有默认参数的函数

当函数有可选参数时，我们必须检测参数是否被传递了。

在一些场景中，应为一个可选参数设置默认值。

```ts
function add(foo: number, bar: number, foobar?: number): number {
  return foo + bar + (foobar !== undefined ? foobar : 0)
}
```

这个函数并没有错误，但是可以通过提供 foobar 参数的默认值，来代替标记其为可选参数，以改善其可读性。

```ts
function add(foo: number, bar: number, foobar: number = 0): number {
  return foo + bar + foobar
}
```

只需要在声明函数时使用 " = " 操作符提供一个默认值，即可指定函数参数是可选的。TS 编译器会在 JS 输出结果中生成一个 if 结构，在 foobar 参数没有传递给函数时设置一个默认值。

```js
function add(foo, bar, foobar) {
  if (foobar === void 0) {
    foobar = 0
  }
  return foo + bar + foobar
}
```

void 0 是 TS 编译器检测一个变量是否为 undefined 的用法。几乎所有开发者都使用 undefined 变量，几乎所有编译器都使用 void 0。

和可选参数一样，默认参数必须位于所有必选参数列表的后面。

### 有剩余参数的函数

已经学习了如何调用 add 函数并传递两个或三个参数，但是如果希望允许其他开发者传递四个或者五个参数呢？不得不再添加两个额外的默认参数或者可选参数。那如果希望允许开发者传递任意数量的参数呢？解决方案是使用剩余参数。剩余参数语法允许把不限量的参数表示为一个数组：

```ts
function add(...foo:number[]):number {
  let result = 0
  for (let i = 0, j = foo.length; i < j; i++) {
    result += foo[i]
  }
  return result
}
```
