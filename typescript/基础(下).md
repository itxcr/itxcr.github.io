### 错误处理

### Error类

运行时错误发生后会抛出一个 Error 类:

```ts
throw new Error()
```

可以创建自定义错误，比如传一个参数给 Error 类的构造器：

```js
throw new Error('测试抛出错误');
```

若需要更多的自定义及控制能力，可以通过继承实现：

```ts
module CustomException {
    export declare class Error {
        public name: string
        public message: string
        public stack: () => any
        constructor(message?:string) {
        }
    }
    export class Exception extends Error {
        constructor(public message: string) {
            super(message);
            this.name = 'Exception'
            this.message = message
            this.stack = ():any => new Error().stack
        }
        toString() {
            return this.name + ':' + this.message
        }
    }
}
```

在上面代码中，声明了一个 Error 类，该类存在于运行时，但并非 TS 自带，所以需要自己声明。然后创建了一个继承自 Error 类的 Exception 类，最后创建了 CustomError 继承自 Exception 类：

```ts
class CustomError extends CustomException.Exception {
}
```

### try ... catch 语句和 throw 语句

catch 语句会捕获 try 中抛出的异常。在 try 中写的代码，如果运行失败了，程序就会运行 catch 中的代码。

另外还有一个可选的 finally，会在 try 和 catch 运行和执行：

```js
try {
    // 希望运行的代码
    throw new Error('测试');
}
catch (e) {
    // try 中抛出异常时运行的代码
    console.log(e);
}
finally {
    // 无论是否抛出异常都会执行的代码
    console.log('finally');
}
```

在大多数编程语言中，包括 TS，抛出和接收异常的操作很耗费资源，在不必要的情况下应尽量避免使用它们，因为这会影响性能。因此，在影响性能的函数和循环中尽量不要使用 try...catch 和 throw 语句。

### 注解和装饰器

注解是一种为类声明添加元数据的方法。然后，元数据就可以被诸如依赖注入容器这样的工具所使用。

注解没有称为语言标准，但是，装饰器已经是ES7的标准特性。它用来在代码的设计阶段注释和修改类和类的属性。

注解和装饰器在外观上十分相似：

- 注解和装饰器很像是同一个东西。在使用者的角度来看，它们有相同的语法。唯一的区别就是，在使用注解时，不用去关心它是如何将元数据加入到代码里来的。装饰器更像是一个接口，用来构建一个以注解功能结尾的东西。目前看来，只需要关注装饰器，因为它才是真正的语言标准。AtScript 是 TS 和 TS 实现的装饰器的结合。

将使用下面这个类来说明如何使用装饰器：

```ts
class Person {
    public name: string
    public surname: string
    constructor(name: string, surname: string) {
        this.name = name
        this.surname = surname
    }
    public saySomething(something: string) {
        return this.name + '' + this.surname + 'says:' + something
    }
}
```

可供使用的装饰器一共有 4 种，分别用来装饰：类、属性、方法和参数。

### 类装饰器

- 类装饰器是指接受一个类构造函数作为参数的函数，并且返回 undefined、参数中提供的构造函数或一个新的构造函数。返回 undefined 等同于返回参数中提供的构造函数。

类装饰器用来修改类的构造函数。如果装饰器返回 undefined，那么类仍然使用原来的构造函数。如果装饰器有返回值，那么返回值会被用来覆盖类原来的构造函数。

将要创建一个名为 logClass 的类装饰器。使用如下代码创建一个装饰器：

```ts
function logClass(target: any) {
    // ...
}
```

上面类装饰器没有任何逻辑，但是已经可以使用它装饰一个类。若想使用装饰器，需要使用 @ 符号：

```ts
@logClass
class Person {
    public name: string
    public surname: string
    constructor(name: string, surname: string) {
        this.name = name
        this.surname = surname
    }
    public saySomething(something: string) {
        return this.name + '' + this.surname + 'says:' + something
    }
}
```

如果已经声明并使用了一个装饰器，那么在经过 TS 编译器编译后的代码中，将会有一个名为 __decorate 的函数，它用来在运行时装饰类。在编译了上面的代码后，可以看到在运行时：

```js
var Person = /** @class */ (function () {
    function Person(name, surname) {
        this.name = name;
        this.surname = surname;
    }
    Person.prototype.saySomething = function (something) {
        return this.name + '' + this.surname + 'says:' + something;
    };
    Person = __decorate([
        logClass
    ], Person);
    return Person;
}());
```

下面实现类装饰器的逻辑部分：

```ts
function logClass(target: any) {
    // 保存原构造函数的引用
    const original = target
    // 用来生成类的实例的工具方法
    function construct(constructor, args) {
        const c: any = function () {
            return constructor.apply(this, args)
        }
        c.prototype = constructor.prototype
        return new c()
    }
    // 新的构造函数行为
    const f: any = function (...args) {
        console.log("New:" + original.name)
        return construct(original, args)
    }
    // 复制原型,保证 instanceof 操作能正常使用
    f.prototype = original.prototype
    // 返回新的构造函数(会覆盖原构造函数)
    return f
}
```

类装饰器接受一个参数，即类的构造函数。这意味着 target 参数就是 Person 类的构造函数。

这个装饰器先复制了类的原构造函数，然后定义了一个名为 construct 的工具函数，来生成类的实例。

装饰器用来为元素添加一些额外的逻辑或元数据。当想要扩展一个函数（类的方法或构造函数）的功能时，需要往原函数上包一个新函数，新函数里有额外的逻辑，且能执行原函数里的方法。

在上面的装饰器里，给类的构造函数添加了一些额外的逻辑，即在类的实例被创建时，在控制台打印类的名字。为了实现它，创建了一个名为 f 的新构造函数。新的构造函数 包含了新添加的逻辑，并且使用 construct 函数来执行原构造函数。

在装饰器的最后，原构造函数的原型被赋值到了新的构造函数上来保证 instanceof 操作符在新的构造函数上使用时，也会返回正确的结果。最后，新的构造函数被返回，并且 TS 编译后的代码会使用它来覆盖原来的构造函数。

在装饰了类的构造函数后，创建一个新的类实例：

```js
var person = new Person('test', 'xcr1');
```

这时，控制台会输出：

```text
New:Person
```

### 方法装饰器

- 方法装饰器是一个接受三个参数的函数：包含这个属性的对象、属性名（字符串或符号）和一个可选参数（属性的描述对象）。这个函数会返回 undefined、参数里提供的属性描述对象或一个新的属性描述对象。返回 undefined 等同于返回参数里提供的属性描述对象。

方法装饰器和类装饰器十分相似，但它不是用来覆盖类的构造函数的，而是用来覆盖类的方法的。

如果方法装饰器返回的不是 undefined，那么返回值将会覆盖方法的属性描述对象。

- 属性描述对象是一个可以通过 `Object.getOwnPropertyDescriptor()` 方法获取到的对象

先定义一个没有任何行为的名为 logMethod 的方法装饰器：

```ts
function logMethod(target: any, key: string, descriptor: any) {
    // ...
}
```

可以使用它来装饰 Person 类中的一个方法：

```ts
@logMethod
// @ts-ignore
public saySomething(something: string) {
    return this.name + '' + this.surname + 'says:' + something
}
```

方法装饰器被调用时，带有以下参数：

- 包含了被装饰方法的类的原型，即 Person.prototype
- 被装饰的方法的名字，即 saySomething
- 被装饰方法的属性描述对象，即 `Object.getOwnPropertyDescriptor(Person.prototype, saySomething)`

下面实现装饰器的逻辑部分：

```ts
function logMethod(target: any, key: string, descriptor: any) {
    // 保存原方法的引用
    const originMethod = descriptor.value
    // 编辑 descriptor 参数的 value 属性
    descriptor.value = function (...args: any[]) {
        // 将方法参数转换成字符串
        const a = args.map(a => JSON.stringify(a)).join()
        // 执行方法 得道其返回值
        const result = originMethod.apply(this, args)
        // 将返回值转化为字符串
        const r = JSON.stringify(result)
        // 将函数调用细节打印到控制台
        console.log(`Call: ${key}(${a}) => ${r}`)
        return result
    }
    // 返回编辑后的属性描述对象
    return descriptor
}
```

和实现类装饰器时一样，以创建被装饰元素的副本开始。没有直接通过类的原型（target['key']）来访问方法，而是通过属性描述对象（descriptor.value）。

然后创建了一个新函数来代替被修饰的函数。新的函数除了调用了原函数之外，还包含一些额外逻辑把函数名和每次调用时包含的参数打印到控制台。

调用被装饰的方法后，方法名和参数会被打印到控制台：

```js
var me = new Person('xcr', '666');
me.saySomething('1');
// Call: saySomething("1") => "xcr666says:1"
```

### 属性装饰器

- 属性装饰器函数是一个接受两个参数的函数：包含了这个属性的对象和这个属性的属性名（一个字符串或一个符号），不会返回一个属性的描述对象。

属性装饰器和方法装饰器十分相似。主要的区别在于，一个属性装饰器没有返回值且没有第三个参数（属性描述对象）。

创建一个名为 logProperty 的属性装饰器：

```ts
function logProperty(target: any, key: string) {
    // ...
}
```

可以用它来装饰一个 Person 类的属性：

```ts
class Person {
    @logProperty
    public name: string
    public surname: string
    // ...
```

和之前一样，将使用一个新属性来代替原来的属性，新属性会表现得与原属性一致，除了在更改时会将改变的值打印到控制台中：

```ts
function logProperty(target: any, key: string) {
    // 属性值
    let _val = this[key]
    // 属性的 getter
    const getter = function () {
        console.log(`Get:${key}=>${_val}`)
        return _val
    }
    // 属性的 setter
    const setter = function (newVal) {
        console.log(`Set:${key}=>${newVal}`)
        _val = newVal
    }
    // 删除属性，在严格模式下，如果对象是不可配置的，删除操作符将会抛出一个错误
    // 在非严格模式下，则会返回 false
    if (delete this[key]) {
        Object.defineProperty(target, key, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        })
    }
}
```

在上面装饰器里，创建了一个原属性的副本，并且分别声明了两个函数：getter（读取属性时会被调用）和 setter（设置属性值时会被调用）。

在之前的装饰器中，返回值总被用来覆盖修饰的元素，但属性装饰器没有返回值，不能使用返回值来覆盖被修饰属性的值，所以手动删除了原属性，并使用 `Object.defineProperty` 函数创建了新属性。

在使用上述装饰器装饰了 name 属性后，可以在控制台查看属性的每一次改变：

```ts
const me = new Person('xcr', '666')
// Set:name=>xcr1
me.name = 'xcr1'
// Get:name=>xcr1
const n = me.name
```

### 参数装饰器

- 参数装饰器函数是一个接受三个参数的函数：一个包含了被装饰参数的方法的对象、方法的名字（或 undefined）和参数在参数列表中的索引。这个装饰器的返回值将会被忽略。

创建一个名为 addMetadata 的参数装饰器

```ts
function addMetadata(target: any, key: string, index: number) {
    // ...
}
```

可以使用这个装饰器装饰一个参数：

```ts
public saySomething(@addMetadata something: string) {
    return this.name + '' + this.surname + 'says:' + something
}
```

参数属性没有返回值，这意味着将不能覆盖这个包括被修饰参数的方法。

可以使用参数装饰器来为原型（target）添加一些元数据。在下面的实现中，将会在类的原型上添加一个名为 `log_${key}_parameters`的数组，key为包含被装饰参数的方法的名字：

```ts
function addMetadata(target: any, key: string, index: number) {
    const metadataKey = `_log_${key}_parameters`
    if (Array.isArray(target[metadataKey])) {
        target[metadataKey].push(index)
    }else {
        target[metadataKey] = [index]
    }
}
```

为了让更多参数可以被装饰，会检查这个新属性是否为一个数组，如果不是，将初始化它为一个包含参数位置索引的数组，否则就只将参数的位置索引推入数组。

单独的参数装饰器并不是很有用，它需要和方法装饰器结合，参数装饰器用来添加元数据，然后通过方法装饰器来读取它：

```ts
@readMetadata
public saySomething(@addMetadata something: string) {
    return this.name + '' + this.surname + 'says:' + something
}
```

这个 readMetadata 方法装饰器将读取通过参数装饰器添加的元数据，并在它执行时，不再展示所有的参数，而是仅仅打印被装饰的参数：

```ts
function readMetadata(target: any, key: string, descriptor: any) {
    const originalMethod = descriptor.value
    descriptor.value = function (...args: any[]) {
        const metadataKey = `_log_${key}_parameters`
        const includes = target[metadataKey]
        if (Array.isArray(includes)) {
            for (let i = 0; i < args.length; i++) {
                if (includes.indexOf(i) !== -1) {
                    const arg = args[i]
                    const argStr = JSON.stringify(arg) || arg.toString()
                    console.log(`${key} arg[${i}]:${argStr}`)
                }
            }
            const result = originalMethod.apply(this, args)
            return result
        }
    }
    return descriptor
}
```

执行 saySomething 方法：

```ts
const me = new Person('xcr', '666')
me.saySomething('hello')
```

readMetadata 装饰器将会展示被添加到元数据（类原型上的 _log_saySomething_parameters 属性 ）中的参数的值：

```js
saySomething arg[0]:"hello"
```

- 需要注意的是，在上面例子中，使用了类原型的属性来保存原数组。后面会学到反射元数据 API，这个 API 专门用来生成和读取元数据，在处理装饰器和元数据时，使用它更好。

### 装饰器工厂

- 装饰器工厂是一个接受任意数量参数的函数：并且必须返回上述任意一种装饰器。

大多数时候只会去使用装饰器。可以使用装饰器工厂来使装饰器更容易被使用：

```ts
@logClass
class Person {
    @logProperty
    public name: string
    @logMethod
    public saySomething(@logParameter something: string): string {
        return this.name + 'says:' + something
    }
}
```

上面代码的问题在于，作为开发者，需要知道 logMethod 只能被用于装饰一个方法。例子中只是因为装饰器的名字，让这个问题看上去不那么严重。

一个更好的解决方案是，让开发者使用一个 @log 装饰器，无需担心自己是否使用了正确类型的装饰器：

```ts
@log
class Person {
    @log
    public name: string
    @log
    public saySomething(@log something: string): string {
        return this.name + 'says:' + something
    }
}
```

可以通过创建一个装饰器工厂来实现它。装饰器工厂指能鉴别该使用哪种装饰器并返回它的函数：

```ts
function log(...args: any[]) {
    switch (args.length) {
        case 1:
            return logClass.apply(this, args)
        case 2:
            // 由于属性装饰器没有返回值
            // 使用 break 取代return
            logProperty.apply(this, args)
            break
        case 3:
            if (typeof args[2] === 'number') {
                logParameter.apply(this, args)
            }
            return logMethod.apply(this, args)
        default:
            throw new Error("装饰器不符合规范")
    }
}
```

装饰器工厂通过参数的数量和类型来判断返回的装饰器类型。

### 带有参数的装饰器

可以使用一种特殊的装饰器工厂来配置装饰器的行为。例如，可以为一个类装饰器传递一个字符串参数：

```ts
@logClass("option")
class Person { 
    // ....
```

为了给装饰器传递参数，需要使用一个函数来包裹装饰器。这个包裹函数接收参数并返回一个装饰器：

```ts
function logClass(option: string) {
    return function (target: any) {
        // 类装饰器逻辑
        // 可以访问装饰器的参数
        console.log(target, option)
    }
```

这可以运用到任一种装饰器中。

### 反射元数据 API

已经学习了如何使用装饰器来修改和扩展类的方法与属性的行为，也学习了如何使用装饰器来为一个被装饰的类添加元数据。

TS 仅在代码设计阶段使用类型，但一些特性，诸如依赖注入、运行时类型断言、反射和测试，需要运行时的类型信息才可以实现。

这些都将不是问题，因为可以使用装饰器来生成元数据，这些元数据会携带类型信息，它们可以在运行时被处理。

当TS团队思考怎么让开发者生成类型元数据时，他们保留了一些特殊的装饰器名。

当时的想法是，当一个元素被保留的装饰器装饰后，编译器会自动添加类型信息到元素上。这些保留的装饰器如下：

- TS 编译器将会在这些保留装饰器的参数中添加额外的信息
  - @type：被装饰目标序列化后的类型
  - @returnType：被装饰目标若为函数，则为其序列化后的返回类型，否则为 undefined
  - @parameterTypes：如果它是一个函数、undefined 或其他类型，这是被装饰目标序列化后的参数类型
  - @name：被装饰目标的名字

不久之后，TS 团队决定使用反射元信息API（ES7特性）来代替这些保留装饰器。

它的思想与使用保留装饰器十分相似，但使用了反射元信息 API 替代保留装饰器，来获取元信息。TS 文档中定义了三种保留元数据键：

- 类型元数据使用元数据键：design：type
- 参数类型元数据使用元数据键：design：parametypes
- 返回值元数据使用元数据键：design：returntype

来看看如何使用反射元数据 API，这需要引用一个名为 reflect-metadata 的 npm 包：

