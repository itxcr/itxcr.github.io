### 运行时

TS 的运行时就是 JS 的运行时。TS 只存在于程序的设计阶段。在运行前，TS 代码会被编译为 JS 代码，然后 JS 代码被执行。

当编译 TS 代码时，将会生成 JS 代码，然后在服务端（Node.js）或客户端（浏览器）中执行。然后就可能会遇到一些扰人的运行时问题：

- 运行时环境
- 事件循环
- this 操作符
- 原型
- 闭包

### 环境

在开发一个 TS 应用之前，运行时环境是首先要考虑的事情。一旦编译完 TS 代码，它可能会被不同的 JS 引擎执行。主要有浏览器，如 Chrome、Firefox或 IE，也可能是在 Node.js 或 RingoJS 环境中运行的服务端程序或桌面应用。

所以需要谨慎使用那些仅在特定运行时环境中才可用的变量。

W3C 对文档对象模型（DOM）有如下定义：

- 文档对象模型是用于动态访问和更新页面中视图结构的接口，它独立于平台和语言。模型的数据可以被进一步处理和修改，并且修改后会反映在当前视图中。

和 DOM 类似，浏览器对象模型（BOM）也是一个仅在浏览器运行环境下特有的对象集合。BOM 包含了导航栏、历史记录、屏幕、地址栏和文档等窗口对象。

必须明确 DOM 只存在于浏览器中，它并不是 JS 的一部分。如果在浏览器中运行应用，那么可以访问到 DOM 和 BOM。但是，在像 Node.js 或 RingoJS 这样的纯 JS 环境中，它们是不存在的。在那些服务端的运行环境中，也存在一些浏览器中不能访问的对象（如 Node.js 中的 process.stdin）。

另外，还需要把同一 JS 运行时的不同版本考虑在内。我们的应用经常需要兼容多个浏览器或多个版本的 Node.js。处理这个问题的一个较好的实践是添加一个逻辑，在使用一个特性前，先检测一下这个特性是否存在。

- Modernizr
  - 可以帮助实现开发浏览器应用时的特性检测。

### 运行时的一些概念

TS 的运行时环境有一个基于事件循环的并发模型。这个模型与其他如 C 或 Java 这样的变成语言中的模型非常不同。在讨论事件循环前，需要了解下其他的运行时概念。

下图为一些关键的运行时概念的模拟图：堆（heap）、栈（stack）、队列（queue）和帧（frame）：

![image-20220422205306534](https://cdn.jsdelivr.net/gh/itxcr/oss/pic/202204222055848.png)

### 帧

一个帧是一个连续的工作单元。在上图所示中，帧表现为栈中的小块。

当一个 JS 函数被调用时，运行时环境就会在栈中创建一个帧。帧里保存了特殊函数的参数和局部变量。当函数返回时，帧就被从栈中推出。来看一个例子：

```js
function foo(b) {
    let a = 12
    return a + b + 35
}

function bar(x) {
    let m = 4
    return foo(m * x)
}
```

在声明了 foo 和 bar 函数后，执行 bar 函数：

```js
console.log(bar(21)) // 131
```

当 bar 被执行时，运行时将会创建一个包含 bar 的参数和所有局部变量的帧。这个帧（上图中的小正方形）被添加在了栈的顶部。

bar 函数在内部调用了 foo 函数。当 foo 函数被调用时，栈的顶部就又创建了一个新的帧。当 foo 函数执行完毕（foo函数返回）后，栈顶部对应的帧就被移除。当 bar 函数执行完毕后，相应的帧也同样被移除。

如果在 foo 函数中又调用了 bar 函数，那么就创建了一个无限的函数调用循环。每调用一次函数，一个新的帧就被添加在栈的顶部，并且最终，栈会被完全填满，然后抛出一个错误。叫做栈溢出错误。

### 栈

栈包含了一个信息在执行时的所有步骤（帧）。栈的数据结构为一个后进先出的对象集合。因此，当一个帧被加入到一个栈中时，它总是被添加在最上面。

由于栈是一个后进先出的集合，所以事件循环会从上至下地处理栈中的帧。单帧所依赖的其他帧，将会被添加在此帧的上面，以保证它从栈中可以获取到需要的依赖信息。

### 队列

队列中包含一个待执行信息的列表，每一个信息都与一个函数相互联系。当栈为空时，队列中的一条信息就会被取出并且被处理。处理的过程为调用该信息所关联的函数，然后将此帧添加到栈的顶部。当栈再次为空时，本次信息处理即视为结束。

在上图中，队列中的方块表示其中的信息。

### 堆

堆是一个内存存储空间，它不关注内部储存的内容的保存顺序。堆中保存了所有正在被使用的变量和对象。同时也保存了一些当前作用域已经不再会被用到，但还没有被垃圾回收的帧。

### 事件循环

并发是指同一时间有两个或更多的操作一起执行。不过由于运行时执行在一个单线程中，所以这意味着我们并不能达到真正意义上的并发。

事件循环内的信息是线性执行的。这意味着它接收到一个消息后，在处理完毕之前，不会再处理其他任何信息。

- 正如可以使用关键字 yield 和生成器函数来暂停一个函数的执行。

每当一个函数被调用，队列中就被加入一个新的信息。如果栈是空的，那么函数就会立刻执行（即表示该函数的帧被添加到了栈中）。

当所有的帧都被加入栈中后，栈便开始从上至下的一个个清除（执行）这些帧。最后，栈会被清空，然后下一个信息将会被处理。

- HTML5 中的 web worker 可以在不同的线程内处理后台任务。它们拥有各自的队列、堆和栈。

使用事件循环的一个好处是，执行顺序是非常容易预测且容易追踪的。另一个好处就是，在事件循环内可以进行非阻塞 I/O 操作。这意味着当一个应用在等待 I/O 操作时的执行结果时，它还可以处理其他事情，比如处理用户输入。

事件循环的一个缺点是，当一个信息需要大量时间来处理时，应用会变得无响应。一个好的做法是，保持每个信息处理尽量简短，可能的话，将一个信息函数分割为多个小函数。

### this 操作符

JS 中的 this 操作符的值通常由它所属的函数被调用的方式来决定。它的值不能在执行时通过赋值操作来设置，并且同一个函数以不同的方式被调用，其 this 值也可能会不同。

- this 操作符在严格模式下的表现也会与在非严格模式下有所不同。

### 全局上下文中的 this 操作符

在全局上下文中，this 操作符总是指向全局对象。在浏览器中，window 对象即是全局对象：

```js
console.log(this === window) // true
this.a = 37
console.log(window.a) // 37
console.log(this.document === window.document) // true
```

### 函数上下文中的 this 操作符

函数内的 this 操作符的值由函数被调用的方式所决定。在非严格模式下，如果简单调用一个函数，那么内部的 this 将指向全局对象：

```ts
function f1() {
    return this
}

f1() === window // true
```

但是，如果在严格模式中这样调用函数，那么内部的 this 将会指向 undefined：

```js
console.log(this) // 全局 window
function f2() {
    'use strict'
    return this // undefined
}

console.log(f2()) // undefined
console.log(this) // window
```

但是，如果函数以实例的方法的形式被调用，this 操作符将会指向该实例。换句话说，调用一个类的成员方法，那么 this 操作符就会指向该类：

```js
let p = {
    age: 37,
    getAge: function () {
        return this.age // this 指向类实例 p
    }
}
console.log(p.getAge()) // 37
```

上面例子中，使用对象字面量声明了一个名为 p 的对象，使用原型声明的方法也一样：

```js
function  Person() {}
Person.prototype.age = 37
Person.prototype.getAge = function () {
    return this.age
}
let p = new Person()
console.log(p.age)  // 37
console.log(p.getAge())  // 37
```

当一个函数被作为构造函数（使用 new 关键字） 调用时，this 操作符将指向正在被构造的对象：

```js
function  Person() {
    this.age = 37
}
let p = new Person()
console.log(p.age)  // 37
```

### call、apply 和 bind 方法

所有的函数都从 Function.prototype 中继承了 call、apply 和 bind 方法。我们可以使用这些方法来设置函数内部 this 操作符的值。

call 和 apply 方法非常相似，它们都会先设置函数中 this 操作符的值，并且执行这个函数。主要区别是，apply 以数组的形式接受传递给函数的参数，而 call 则是以单个分开参数的形式。

- A（apply）对应数组（array）
- C（call） 对应逗号 （comma）

下面定义一个名为 Person 的类，这个类有两个属性（name 和 surname）和一个方法（greet）。greet 方法在内部使用了 this 操作符来访问实例的 name 和 surname属性：

```ts
class Person {
    public name: string;
    public surname: string;

    constructor(name: string, surname: string) {
        this.name = name
        this.surname = surname
    }

    public greet(city: string, country: string) {
        let msg = `My name is ${this.name} ${this.surname}`
        msg += `I'm from ${city}(${country})`
        console.log(msg)
    }
}
```

声明了 Person 类后，创建一个它的实例：

```ts
let person = new Person('test', 'xcr')
```

如果执行 greet 方法，将得到预期的输出：

```js
person.greet('a', 'b'); // My name is test xcrI'm from a(b)
```

另外，也可以通过使用 call 和 apply 函数调用该方法。要将第一个参数指定为 person 对象，因为希望 greet 方法内部的 this 操作符指向它：

```js
person.greet.call(person, 'test', '1');
person.greet.apply(person, ['greet', '1']);
```

如果将方法内部的 this 指向其他值，那么在 greet 方法内，将访问不到 name 和 surname 属性：

call 和 apply 方法只在我们的确希望函数内的 this 操作符指向其他值时才有意义：

```ts
var valueOfThis = {
    name: 'test',
    surname: 'test1'
};
person.greet.call(valueOfThis, 'test', '1');
person.greet.apply(valueOfThis, ['greet', '1']);
// My name is test test1I'm from test(1)
// My name is test test1I'm from greet(1)
```

bind 方法也可以修改函数内 this 操作符的值，但不执行它。

调用函数的 bind 方法时，它返回了一个和原函数具有相同函数体和作用域的新函数，但是（函数体）内部 this 操作符指向的值，已被永久的改变为传递给 bind 方法的第一个参数，不论之后这个函数如何被调用，都不会变。

来看一个例子：

```js
var person = new Person('test', 'xcr');
```

然后，可以使用 bind 方法来使 greet 函数成为一个具有相同作用域和函数体的新函数：

```ts
const greet = person.greet.bind(person)
```

如果再次使用 bind 或 apply 方法来调用 greet 函数，会发现，无论怎么被调用，函数内部的 this 操作符的值都不会再被改变：

```ts
greet.call(person, '1', '2');
greet.apply(person, ['3', '4']);
// My name is test xcrI'm from 1(2)
// My name is test xcrI'm from 3(4)
greet.call(null, '1', '2');
greet.apply(null, ['3', '4']);
// My name is test xcrI'm from 1(2)
// My name is test xcrI'm from 3(4)
var valueOfThis = {
    name: 'test',
    surname: 'test1'
};
greet.call(valueOfThis, '1', '2');
greet.apply(valueOfThis, ['3', '4']);
// My name is test xcrI'm from 1(2)
// My name is test xcrI'm from 3(4)
```

- 除非明确知道后果，否则使用 apply、call 和 bind 函数是不推荐的做法。它们可能会对其他开发者产生对运行时的困惑。

一旦使用 bind 方法为一个函数内的 this 操作符进行了绑定，就不能再次覆盖它：

```js
var valueOfThis = {
    name: 'test',
    surname: 'test1'
};
const greet = person.greet.bind(valueOfThis)
greet.call(null, '1', '2')
greet.apply(null, [3, 4])
// My name is test test1I'm from 1(2)
// My name is test test1I'm from 3(4)
```

- 一般不推荐使用 bind、apply 和 call 方法，因为它们会导致其他人的困惑。改变函数内的默认 this 操作符的值可能会导致产生未预期的结果，仅在必要时才使用它们，并且为代码加上合适的注释，来减少潜在的可维护性问题。

### 原型

当编译 TS 代码后，所有的类和对象都变为了 JS 对象。有时会在应用中遇到一些不符合预期的运行时问题。如果没有理解 JS 的继承机制，那么就很难找到和理解问题的根源。这些知识将有助于更好地控制应用在运行时的行为。

运行时的继承系统使用的是原型继承模型。在一个原型继承模型中，并没有类，对象直接继承自对象。但是，可以使用原型来模拟对象。

在运行时，几乎所有的 JS 对象都有一个内部的名为 prototype 的属性。这个属性的值是一个对象，这个对象中包含了一些属性（数据）和方法（行为）。

在 TS 中，使用基于类的继承系统：

```ts
class Person {
    public name: string;
    public surname: string;
    public age: number = 0;

    constructor(name: string, surname: string) {
        this.name = name
        this.surname = surname
    }

    greet() {
        let msg = `My name is ${this.name} ${this.surname}`
        msg += `I'm ${this.age}`
        return msg
    }
}
```

声明了一个名为 Person 的类。在运行时，这个类的继承将会使用到原型：

```js
var Person = /** @class */ (function () {
    function Person(name, surname) {
        this.age = 0;
        this.name = name;
        this.surname = surname;
    }
    Person.prototype.greet = function () {
        var msg = "My name is ".concat(this.name, " ").concat(this.surname);
        msg += "I'm ".concat(this.age);
        return msg;
    };
    return Person;
}());
```

TS 编译器使用一个立即调用函数表达式包装了一个对象声明。

### 实例属性与类属性的对比

由于 JS 是动态编程语言，可以在运行时为一个实例添加属性和方法，并且它们不必为对象（类）声明中的一部分。来看一个例子：

```js
function Person(name, surname) {
    this.name = name;
    this.surname = surname;
}
let me = new Person('test', 'xcr')
me.email = 'test@test.com'
```

这里，为一个名为 Person 的对象定义了一个构造函数，它接受两个参数（name 和 surname）。然后创建了一个 Person 类的实例，并为其添加一个名为 email 的新属性。在运行时，可以使用 for...in 语句来检查实例的属性：

```js
for (let prototype in me) {
    console.log('prototype:' + prototype, 'value:' + me[prototype])
}
// prototype:name value:test
// prototype:surname value:xcr        
// prototype:email value:test@test.com
```

所有这些属性都是实例属性，因为它们保存着每个实例各自的值。例如，如果创建了一个新的 Person 类的实例，那么它的属性也将保存实例自己的值：

```ts
let me = new Person('xcr')
let hero = new Person('hero')
console.log(hero.name) // herom
console.log(me.name) // xcr
```

通过在构造函数中使用 this 操作符来定义这些属性，因为在构造函数中， this 指向对象的原型。所以也可以直接在对象的 prototype 属性上定义实例属性：

```ts
Person.prototype.name = name // 实例属性
Person.prototype.surname = surname // 实例属性
```

还可以声明类的属性和方法。它们之间的主要区别在于，类的属性和方法的值在它的实例间是共享的。类的属性和方法有时也被称为静态属性和方法。

类属性经常用来保存一些静态值：

```ts
function MathHelper() {
}
MathHelper.PI = 3.14159265359;
```

类方法常常被作为工具函数使用，为其提供参数，经过计算，然后返回一个结果：

```ts
// 类方法
MathHelper.areaOfCircle = function (radius) {
    return radius * radius * this.PI
}
// 类属性
MathHelper.PI = 3.14159265359;
```

上面，在一个类方法（areaOfCircle）内访问了类属性（PI）。可以在实例方法中访问类属性，但不可以在类属性或方法中访问实例属性或方法。可以通过将 PI 定义为实例属性来解释：

```js
function MathHelper() {
    // 实例属性
    this.PI = 3.14159265359;
}
```

如果尝试在类方法中访问 PI，它将是 undefined:

```ts
// 类方法
MathHelper.areaOfCircle = function (radius) {
    return radius * radius * this.PI // this.PI 为 undefined
}
console.log(MathHelper.areaOfCircle(2)) // NaN
```

当需要从实例方法中访问类属性或方法时，可以使用原型的 constructor 属性来取得它们：

```ts
function MathHelper() {
}
// 类属性
MathHelper.PI = 3.14159265359;

// 实例方法
MathHelper.prototype.areaOfCircle = function (radius) {
    return radius * radius * this.constructor.PI
}
let math = new MathHelper()
console.log(math.areaOfCircle(5)) //78.53981633975
```

由于原型的 constructor 属性返回了对象构造函数的引用，所以可以在 areaOfCircle（实例方法）中通过原型访问到 PI （类属性）。

在 areaOfCircle 方法中，this 操作符返回了对象原型的引用，可以推断出 this.constructor 等于 MathHelper.prototype.constructor，因此，MathHelper.prototype.constructor 等于 MathHelper。

### 基于原型的继承

创建一个新的 TS 类，让其继承自 Person 类：

```ts
class SuperHero extends Person {
    public superpower: string
    constructor(name: string, surname: string, superpower: string) {
        super(name, surname);
        this.superpower = superpower
    }
    userSuperPower() {
        return `I‘m using my ${this.superpower}`
    }
}
```

上述 SuperHero 类继承自 Person 类，它有一个额外的属性（superpower）和 方法（userSuperPower）。如果编译代码，在编译结果中，下面这段代码将引起我们的注意：

```js
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
```

在函数第一次执行之前，this 操作符指向全局对象，在那时，它并没有一个名为 `__extends` 的方法。这意味着那时 `__extends` 变量的值为 undefined。

当函数第一次被执行完毕后，函数表达式（即这个匿名函数）的值被保存在了全局对象的 __extends 属性中：

```js
console.log(this.__extends) // extends(n, e, t)
```

TS 在每次检测到 extends 关键字时就会生成这个函数表达式。但是，它仅仅只会被执行一次（当__extends变量为 undefined 时）。这个行为由第一行代码所实现：

```js
var __extends = (this && this.__extends) || (function () {}....
```

当这行代码被执行后，全局变量中 __extends 变量的值就被赋值为了这个匿名函数。由于是在全局作用域中，所以`var __extends`  和 `this.__extends` 在此刻指向的是同一个对象。

当一个新文件被执行时，它将会发现全局作用域中的 __extends 变量已经可用了。这意味着函数表达式的值只会被赋值到 `__extends`变量一次。

函数表达式的值是一个匿名函数。看看其内部：

```js
function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
```

这个函数接受两个名为 d 和 b 的参数。当调用它时，必须提供一个子类对象构造函数（d）和父类对象构造函数（b）。

匿名函数中的第一行遍历了父类中的所有类属性和方法，并将它复制给了子类：

```js
for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
```

- 当使用 for...in 来遍历一个对象的实例时，它将迭代对象的实例属性。但是，如果使用 for...in 来迭代一个对象的构造函数时，它将会迭代类属性。上面例子中，for...in 被用来继承对象的类属性和方法。为了继承实例属性，将会复制对象的原型。

下面声明了一个名为 __ 的新构造函数。在它的内部，this 操作符被用来访问它的原型。

```js
function __() { this.constructor = d; }
```

在原型中包含了一个名为 constructor 的特殊属性，它返回对象构造函数的引用。这个函数名为 __ 并且此刻 this.constructor 指向的是同一个变量。紧接着，__ 对象的构造函数被赋值为了子类对象(d) 的构造函数。

父类对象构造函数的原型被赋值给了 __ 对象构造函数的原型：

```js
__.prototype = b.prototype
```

在最后，调用了 new __()，其结果被赋值给了子类（d）的原型。

```ts
let superhero = new SuperHero()
console.log(superhero instanceof Person) //true
console.log(superhero instanceof SuperHero) //true
```

可以看到编译生成的 SuperHero 类代码的做法：

```js
var SuperHero = /** @class */ (function (_super) {
    __extends(SuperHero, _super);
    function SuperHero(name, surname, superpower) {
        var _this = _super.call(this, name, surname) || this;
        _this.superpower = superpower;
        return _this;
    }
    SuperHero.prototype.userSuperPower = function () {
        return "I\u2018m using my ".concat(this.superpower);
    };
    return SuperHero;
}(Person));
```

可再次看到这个立即执行函数表达式。这次，立即执行函数表达式接受一个 Person 对象的构造函数作为参数。在函数内部，使用 _super 参数来表示它。之后，SuperHero（子类）和 _super （父类）作为参数传入了 extends 函数。

在后面，看到了 SuperHero 对象的构造函数和 userSuperPower 函数。之所以可以在 SuperHero  函数定义前将其作为参数传入 __extends 函数，是因为函数声明会被提升至作用域的顶部。

- 函数表达式不会被提升。当函数被赋值给一个变量时，变量名会被提升，但它的值（函数本身）不会被提升。

在 SuperHero  构造函数的内部，父类 （Person）的构造函数通过 call 方法被调用：

```ts
_super.call(this, name, surname)
```

可以通过 call 方法设置函数内 this 操作符的指向。在本例中，将父类构造函数中的 this 操作符指向了将被创建的 SuperHero 实例，然后调用它：

```js
function Person(name, surname) {
    // this 指向将被创建的 SuperHero 实例
    this.name = name;
    this.surname = surname;
}
```

### 原型链

当尝试访问一个对象的属性或方法时，运行时将会搜索对象自身原型上的属性和方法，如果没有找到，那么运行时将会继续沿着对象的继承树，在被继承的对象的原型中继续搜索。由于父类对象通过原型链接了子类，称这种继承树为原型链。

来看一个小例子：

```js
var Base = /** @class */ (function () {
    function Base() {
    }
    Base.prototype.method1 = function () { return 1; };
    Base.prototype.method2 = function () { return 2; };
    return Base;
}());
var Derived = /** @class */ (function (_super) {
    __extends(Derived, _super);
    function Derived() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Derived.prototype.method2 = function () { return 3; };
    Derived.prototype.method4 = function () { return 4; };
    return Derived;
}(Base));
```

然后创建 Derived 类的实例：

```js
let derived = new Derived()
```

如果尝试访问 method1 方法，那么运行时将会在实例自己的原型上找到它：

```js
console.log(derived.method1()); // 1
```

这个实例的原型上还有一个名为 method2 的方法（返回3），但是它还继承了一个同名方法（返回2）。当访问这个方法时，访问到的将是对象自己原型上的那个方法（返回3）.这被称为原型遮蔽（property shadowing）：

```js
console.log(derived.method2()); // 3
```

### 访问对象的原型

原型可以通过以下三种方式进行访问：

- Person.prototype：可以直接使用 prototype 来访问原型
- Person.getPrototypeOf(person)：可以使用 getPrototypeOf 函数来访问一个实例对象的原型
- `person.__proto__`：这个属性暴露对象内部可访问的原型属性。
  - `__proto__` 的效率十分低，注重性能要避免使用

### new 操作符

